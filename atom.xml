<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tanzhijian.org</title>
  <id>https://tanzhijian.org/atom.xml</id>
  <updated>2024-09-14T02:23:40Z</updated>
  <link href="tanzhijian.org"/>
  <link href="https://tanzhijian.org/atom.xml" rel="self"/>
  <generator>?</generator>
  <entry>
    <title>一个感动的创业故事</title>
    <link href="https://tanzhijian.org/posts/a_good_story"></link>
    <id>1726251820.5937457</id>
    <updated>2024-09-14T02:23:40Z</updated>
    <published>2024-09-14T02:23:40Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我曾经在《Football Hacker》这本书的读书笔记中分享过这个故事，但我想有必要再分享一次。这次会添加一些润色，以及一些主观的评述，如果想要了解更为真实的故事请直接阅读《Football Hacker》的第五章 outsiders。
</summary>
    <content type="html">
      <h1>一个感动的创业故事</h1>
<p>我曾经在《Football Hacker》这本书的读书笔记中分享过这个故事，但我想有必要再分享一次。这次会添加一些润色，以及一些主观的评述，如果想要了解更为真实的故事请直接阅读《Football Hacker》的第五章 outsiders。</p>
<h2>1.</h2>
<p>想成为比利·比恩的人。</p>
<p>克里斯·安德森这个名字大家可能会陌生，他写过一本《数字游戏：关于足球，你全弄错了……吗？》的书，是为数不多被翻译成中文的足球数据类书籍，他是康奈尔大学教授，教授政治经济学和政治社会学，原本平淡稳定且体面的生活。</p>
<p>但一切在 2009 年因为一本书而改变了，Moneyball。他的妻子是一名经济学家，她经常用这本书来教她的学生“基于证据的决策”，而她把这本书带给了他。其中的故事——棒球俱乐部董事总经理比利·比恩，巧妙地使用数据来克服他低预算的限制，投入了大量工作来寻找具有更强意义的新数据集，深深吸引了他。以至于读完后他发出感叹：“足球界的比利·比恩出现了吗？”</p>
<p>在 Moneyball 的兴趣推动下，他开始在互联网上搜索免费可用的比赛数据。他把数据下载到 Excel 表格中，并探讨相关性。</p>
<p>起初这只是一点乐趣，一个四十多岁的人的爱好，他已经在学术和个人生活中实现了他想要的东西。只有少数人对他的经验分析感兴趣，但随着愈发深入，他作为社会科学家在“日常工作”中使用的分析工具可以轻松应用于足球数据，越多的人开始成为他的读者，他开始逐渐明确了一个理想：“成为足球的比利·比恩。“</p>
<h2>2.</h2>
<p>他们住在纽约州的大学城伊萨卡，有红砖建筑、修剪整齐的草坪和古树，像明信片图片一般的校园。这是一个贵族和阶级的地方，但几乎不具备发动足球革命的自然基础。他们——他和他的妻子莎莉，需要一个好的计划。</p>
<p>在他们看来有两个因素是决定性的：他需要被认真对待；他必须想出一些真正改变比赛的东西，具有破坏性和令人印象深刻性，足以让潜在客户为此支付高额资金。</p>
<p>他们决定先写一本书，“首先，它使我们能够进行广泛的研究，使我们能够更好地了解该行业、其人员及其动态。它还让我有机会向这些人证明数字可以显示非常有趣的东西。”</p>
<p>他联系了 Opta 和 Prozone 等体育数据公司免费使用他们非常昂贵的数据，并承诺在书中对其价值进行宣传，他去了英国和德国的俱乐部，了解他们如何使用数据，2013 年书完成了，就是前面提到的《数字游戏》。他们选择了首先在英国出版，如果在美国出版，就会变成一本“来自美国的足球书籍”，天生得不到重视。</p>
<p>它于 2013 年发行，取得巨大成功，在英国、美国、斯堪的纳维亚半岛和一些亚洲国家拥有众多读者。他们计划的第一部分已经完成。人们确实认真对待他们，他们收获了一个有用的联系网络。</p>
<h2>3.</h2>
<p>但尽管如此，想要进入真正的足球圈仍然很远，数据分析部门很难得到自己俱乐部的赏识。“人们对这些新技术很感兴趣，但仅此而已。”“那里没有任何真正适合技术发展的环境；其中许多只是独自一人在推动，然后慢慢死去。”他们几乎可以确定，许多较大的俱乐部，特别是英超俱乐部，确实投资了技术球探或数据分析师。但他们中的许多人似乎被录用只是因为他们的老板不想被指责为过时。在决策过程方面，这些人的工作充其量只是次要的作用。</p>
<p>如果影响不到上层的决策，就不会产生任何影响。</p>
<p>这一认知导致他们得出了一个根本性的结论，试图说服俱乐部老板采纳他们的想法是没有意义的。他们必须找到愿意购买俱乐部的投资者，并从一开始就以不同的方式管理它。作为两位常春藤联盟教授，他们利用他们的联系人向来自中东、俄罗斯，当然还有来自美国的高净值企业家推销他们的愿景。</p>
<p>他们通过了多次的谈判，多次失败的接触，最终敲定了考文垂，获得了专业足球俱乐部的实践机会。</p>
<h2>4.</h2>
<p>可能到了这里，大家认为一切走向正轨，他们改造球队成功，一个完美的创业故事。但生活中失败与妥协才是常态，你不能像一个将军一样吠叫着命令，更多时候得像一个值得信赖的中尉知道如何在实地完成工作。票务，薪水，更衣室，甚至洗衣房，都需要妥善的处理，而他们并没有办法做好一切，这些才是俱乐部的真实面貌——数据战术只是很小的一部分。</p>
<p>他们于 2015 年接任，俱乐部以第八名结束了本赛季。第二年夏天，便出现了问题——他们认为他们无法解决这些问题。2016年10月，在工作一年多一点后，他们决定认输并离开。</p>
<p>所以这是一个失败的故事吗？</p>
<p>他们发现到目前为止，足球创新完全是由内部人士推动的。他们想创新也可以来自外部的想法，他们想试试局外人是否也能赢，这个想法非常浪漫。</p>
<p>在考文垂之前他成立了一家咨询公司 Anderson and Sally，就经济和金融问题向足球俱乐部的投资者提供建议，尤其是希望其中一位投资者有足够的勇气，把钱花在局外人身上。</p>
<p>他们仍然有退路，2018 年，他们接受了沃里克大学的聘书，回到了经济学和政治学教授的学术生活。他们仍然为足球俱乐部做一些咨询。</p>
<p>所以他们是幸运的，比起大多数我认识的，包括我自己。</p>
<p>这个故事发生在大约十年前，而到了现在，整个行业对于足球的核心圈，仍然是局外人。上层人士痴迷于他们的主观判断，似乎只有需要数据去解释他们的观点时才会引用，而从业者只能在长期不被认可的环境中摸索前行，足球作为一个古老行业，有着太多历史遗留问题。</p>
<p>但愿大家能在不具有包容性的时代，找到属于自己的角色。</p>
<p>也许，只是也许......</p>

    </content>
  </entry>
  <entry>
    <title>zed 的使用体验</title>
    <link href="https://tanzhijian.org/posts/zed_explore"></link>
    <id>1724056563.0601559</id>
    <updated>2024-08-19T16:36:03Z</updated>
    <published>2024-08-19T16:36:03Z</published>
    <author><name>tanzhijian</name></author>
    <summary>最近 zed 发布了 linux 的版本之后一直想尝试一下，开坑新项目的时候直接上手使用了两天，说一下感受吧，由于项目是 python，所以只说 python
</summary>
    <content type="html">
      <h1>zed 的使用体验</h1>
<p>最近 zed 发布了 linux 的版本之后一直想尝试一下，开坑新项目的时候直接上手使用了两天，说一下感受吧，由于项目是 python，所以只说 python</p>
<p>登陆 GitHub 账户授权后可以同步配置，包括设置插件和主题，这属于基本功能了</p>
<p>内置了 GitHub Copilot，前面登陆账户后便可直接使用提示，与 vscode 代码提示部分体验无差，sublime text 这个功能是包装的 neovim 体验稍差，但也仅有这个功能，如果需要使用 copilot chat，需要单打开一个 vscode 当作聊天窗口使用</p>
<p>代码编辑体验，我的主力编辑器是 sublime text，官方比对 zed 快一些，但实际使用体验不到这么点渲染差距，但就论跟手程度，都比 vscode 要好，这也是我为什么长期只用 vscode 做一些边角料工作的原因，不够丝滑，在这一点 zed 和 sublime text 都很好</p>
<p>编辑器内置了 lsp，也就是写什么语言编辑器就会提示安装什么 lsp，python 是 pyright，根据提示安装好便可，同时扩展市场内有 ruff，安装后配置好便可有提示，这点体验与 sublime text 一样，功劳都是 lsp，有了这两个写 python 体验就已经很好了，但目前 zed 的 lsp 功能至少在 python 上面没有 goto definition，这一点非常影响体验，看到 issues 里面已经有很多提交，应该不久就会解决</p>
<p>扩展市场不够丰富，由于是新玩意，这一点跟进的不太足，大部分主流一点的扩展基本还好，但说一个小众需求，我需要一个快捷键选中当前括号内所有内容，编辑器没有内置这个快捷按钮，需要通过插件实现，sublime text 和 vscode 都有，还有主题我经常使用的 monokai pro 这种小众但还算主流的配色也还没有 zed 版本，只能等后续完善了</p>
<p>总的来说，这款编辑器的成熟程度已经无限逼近 sublime text，作为 sublime text 党已经感受到岌岌可危了，毕竟万物皆 rust 的加持下这款编辑器活跃程度只会暴涨，而 vscode 作为万能钥匙一样的存在，再加上 copilot 各种原生体验的加持，目前还不可能撼动</p>

    </content>
  </entry>
  <entry>
    <title>that-game 的可视化功能探讨</title>
    <link href="https://tanzhijian.org/posts/that-game_visualization_explore"></link>
    <id>1721825101.4856722</id>
    <updated>2024-07-24T20:45:01Z</updated>
    <published>2024-07-24T20:45:01Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我发现 that-game 通过设计好的数据格式，或许可以很方便的完成各个级别的可视化
</summary>
    <content type="html">
      <h1>that-game 的可视化功能探讨</h1>
<p>我发现 that-game 通过设计好的数据格式，或许可以很方便的完成各个级别的可视化</p>
<p>文章只为探讨，所有的示例图都为引用的效果图，其具体功能还未实现</p>
<h2>Pitch</h2>
<pre><code class="language-python">pitch = Pitch(length=105, width=68)
pitch.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_pitches_003.png" alt="" /></p>
<pre><code class="language-python">pitch = Pitch(length=105, width=68, vertical=True)
pitch.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_pitches_009.png" alt="" /></p>
<p>这样可以很方便的预览设置的 pitch 是否与自己心目中的一样</p>
<h2>Location</h2>
<p>每一个单独的 Location 都可以单独的查看在 pitch 中的位置</p>
<pre><code class="language-python">location = Location(x=60, y=40, pitch=pitch)
location.show()
</code></pre>
<h2>Event</h2>
<h3>Shot</h3>
<p>可以预览单次射门的状况</p>
<pre><code class="language-python">shot = Shot(...)
shot.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_shot_freeze_frame_001.png" alt="" /></p>
<h3>Pass</h3>
<p>可以预览单次 pass 的传球图，传球方，接球方，球的轨迹，穿过的球员(如果有)</p>
<h3>其他</h3>
<p>其他的一些 type 类我还没有写完，比如 duel, block, dribble, 都会以单点的形式在 pitch 上描绘</p>
<h2>Game</h2>
<p>可以从 game 的角度查看更多</p>
<h3>shots</h3>
<pre><code class="language-python">game = Game(...)
shots = game.shots()
shots.shotmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_scatter_008.png" alt="" /></p>
<h3>passes</h3>
<pre><code class="language-python">passes = game.passes()
passes.network(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/Denmark.png" alt="" /></p>
<pre><code class="language-python">passes.passmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_lines_001.png" alt="" /></p>
<pre><code class="language-python">passes.passmap(id=&#x27;66&#x27;)
</code></pre>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/TAA.png" alt="" /></p>
<h3>其他</h3>
<pre><code class="language-python">touches = game.touches()
touches.heatmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_heatmap_001.png" alt="" /></p>
<h3>games</h3>
<p>可以站在 games 集合的角度查看一些统计数据</p>
<pre><code class="language-python">games = Games(Game(...), Game(...), Game(...))
shots = games.shots()
shots.shotmap(team=&#x27;liverpool&#x27;)
</code></pre>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/Liverpool_shot_map.png" alt="" /></p>
<pre><code class="language-python">touches = games.touches()
touches.countmap()
</code></pre>
<p>接下来就是设计好用的 api 和参数，以及具体代码实现。坑越挖越大了。</p>

    </content>
  </entry>
  <entry>
    <title>关于 that-game</title>
    <link href="https://tanzhijian.org/posts/about_that_game"></link>
    <id>1720540408.808278</id>
    <updated>2024-07-09T23:53:28Z</updated>
    <published>2024-07-09T23:53:28Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我在一些足球事件的项目中大量使用了 [kloppy](https://github.com/PySport/kloppy), 也有一些项目使用了 [socceraction](https://github.com/ML-KULeuven/socceraction) 的 spadl，这两个都可以看成“标准化的足球事件数据结构”，也就是把各个数据源的事件数据读取成一个统一的数据结构，方便后面的一系列计算。
</summary>
    <content type="html">
      <h1>关于 that-game</h1>
<p>我在一些足球事件的项目中大量使用了 <a href="https://github.com/PySport/kloppy">kloppy</a>, 也有一些项目使用了 <a href="https://github.com/ML-KULeuven/socceraction">socceraction</a> 的 spadl，这两个都可以看成“标准化的足球事件数据结构”，也就是把各个数据源的事件数据读取成一个统一的数据结构，方便后面的一系列计算。</p>
<p>但他们各有各的不方便。socceraction 是基于 pandas，使用 pandera 预设一些字段，也可以做数据验证。既然本质上是个 pd.DataFrame, 就有着 df 不可避免的优点和缺点，数据科学家会很习惯他的操作，但在编写实际代码的时候缺乏很好的自动补全，类型推断，在提供的字段上面也偏少：</p>
<pre><code class="language-python">sbl = StatsBombLoader(root=data_path, getter=&quot;local&quot;)
df_games = sbl.games(competition_id=43, season_id=3).set_index(&quot;game_id&quot;)
game_id = 8657
df_teams = sbl.teams(game_id)
df_players = sbl.players(game_id)
df_events = sbl.events(game_id)

home_team_id = df_games.at[game_id, &quot;home_team_id&quot;]
df_actions = spadl.statsbomb.convert_to_actions(df_events, home_team_id)
</code></pre>
<pre><code class="language-python">df_actions.sample(5)
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>game_id</th>
      <th>original_event_id</th>
      <th>period_id</th>
      <th>time_seconds</th>
      <th>team_id</th>
      <th>player_id</th>
      <th>start_x</th>
      <th>start_y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>type_id</th>
      <th>result_id</th>
      <th>bodypart_id</th>
      <th>action_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2307</th>
      <td>8657</td>
      <td>206ac85d-9b2d-475f-88c7-bc4ccc2738e7</td>
      <td>2</td>
      <td>2482.471</td>
      <td>768</td>
      <td>3308.0</td>
      <td>50.3125</td>
      <td>59.075</td>
      <td>39.8125</td>
      <td>64.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>2307</td>
    </tr>
    <tr>
      <th>168</th>
      <td>8657</td>
      <td>5e1b54a1-a93b-4c78-a69f-4ed8c708dbd9</td>
      <td>1</td>
      <td>346.439</td>
      <td>782</td>
      <td>3101.0</td>
      <td>43.3125</td>
      <td>27.625</td>
      <td>42.4375</td>
      <td>28.475</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>168</td>
    </tr>
    <tr>
      <th>938</th>
      <td>8657</td>
      <td>19d08ada-edbc-4fe6-bfd3-00aa03977447</td>
      <td>1</td>
      <td>1821.052</td>
      <td>768</td>
      <td>3468.0</td>
      <td>98.4375</td>
      <td>30.175</td>
      <td>97.5625</td>
      <td>30.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>938</td>
    </tr>
    <tr>
      <th>2310</th>
      <td>8657</td>
      <td>fe9150f6-60d7-429b-8116-115f1b49a1b8</td>
      <td>2</td>
      <td>2489.351</td>
      <td>782</td>
      <td>3077.0</td>
      <td>25.8125</td>
      <td>65.025</td>
      <td>31.9375</td>
      <td>64.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>2310</td>
    </tr>
    <tr>
      <th>903</th>
      <td>8657</td>
      <td>9f489405-7d17-4a0b-9c77-089c49e0b056</td>
      <td>1</td>
      <td>1770.533</td>
      <td>782</td>
      <td>3176.0</td>
      <td>65.1875</td>
      <td>4.675</td>
      <td>65.1875</td>
      <td>12.325</td>
      <td>0</td>
      <td>1</td>
      <td>5</td>
      <td>903</td>
    </tr>
  </tbody>
</table>
</div>
<p>读取过程稍显麻烦，一些在我看来的重要信息，比如 team，player，type， result， bodypart 等都是使用数字作为类别，不存在可读性，如果想要搞清楚数字代表的具体含义需要再调用一个函数：</p>
<pre><code class="language-python">from socceraction.spadl import results_df

results_df()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>result_id</th>
      <th>result_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>fail</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>success</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>offside</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>owngoal</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>yellow_card</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>red_card</td>
    </tr>
  </tbody>
</table>
</div>
<p>都是可哈希对象，其实可以使用字符串使其更具有可读性。而且 spadl 作为为这个库主要的目的，计算 xT, VAEP 的数据结构，支持的 type 也偏少。</p>
<p>kloppy 是则是使用了更为灵活的基于对象的数据模型，有更多的预设读取，如果你只是用他预设的数据源进行操作没什么问题，想更多的自定义操作，他的数据类使用 python dataclass，就没办法有很好的数据验证:</p>
<pre><code class="language-python">from kloppy.domain import Team, Ground

# 这个是正确输入
team = Team(team_id=&quot;ars&quot;, name=&quot;Arsenal&quot;, ground=Ground.HOME)

# 但即使输入一些错误的类型也不会有问题
team = Team(team_id=123, name=123, ground=&quot;HOME&quot;)
</code></pre>
<p>只能通过 mypy 之类的工具寄希望于代码执行之前检查类型，并不具有强制性。同时如果想自定义创建一个 EventDataset 需要太多步骤：</p>
<pre><code class="language-python">from kloppy.domain import (
    BallState,
    DatasetFlag,
    EventDataset,
    Ground,
    KloppyCoordinateSystem,
    Metadata,
    Orientation,
    Period,
    PitchDimensions,
    Player,
    Point,
    Provider,
    ShotEvent,
    ShotResult,
    Team,
)
</code></pre>
<pre><code class="language-python">period = Period(id=1, start_timestamp=0.0, end_timestamp=2827.0)
team = Team(team_id=&quot;ars&quot;, name=&quot;Arsenal&quot;, ground=Ground.HOME)
team_2 = Team(team_id=&quot;che&quot;, name=&quot;Chelsea&quot;, ground=Ground.AWAY)
player = Player(player_id=&quot;saka&quot;, team=team, jersey_no=7, name=&quot;Bukayo Saka&quot;)
coordinates = Point(x=100, y=50)
event = ShotEvent(
    event_id=&quot;1&quot;,
    period=period,
    timestamp=217.32,
    team=team,
    player=player,
    coordinates=coordinates,
    result=ShotResult.OFF_TARGET,
    raw_event=None,
    ball_state=BallState.ALIVE,
    ball_owning_team=team,
    related_event_ids=[],
    state={},
    qualifiers=[],
    freeze_frame=None,
)
</code></pre>
<pre><code class="language-python">pitch_dimensions = PitchDimensions(x_dim=108, y_dim=68)
coordinate_system = KloppyCoordinateSystem(normalized=True, length=108, width=68)
metadata = Metadata(
    teams=[team, team_2],
    periods=[period],
    pitch_dimensions=pitch_dimensions,
    orientation=Orientation.ACTION_EXECUTING_TEAM,
    flags=DatasetFlag.BALL_OWNING_TEAM,
    provider=Provider.OTHER,
    coordinate_system=coordinate_system,
)
</code></pre>
<pre><code class="language-python">custom_dataset = EventDataset(records=[event], metadata=metadata)
</code></pre>
<p>他在描述状态的时候用了大量的 enum，每一个都需要导入，以及确定每一个字段的含义。而我使用最不舒服的一点在构建 team 和 player，他在设计时使用了循环引用:</p>
<pre><code class="language-python">@dataclass
class Player:
    team: &quot;Team&quot;

@dataclass
class Team:
    players: List[Player] = field(default_factory=list)
</code></pre>
<p>可以读他源代码中读取 statsbomb 的一段：</p>
<pre><code class="language-python">        def create_team(lineup, ground_type):
            team = Team(
                team_id=str(lineup[&quot;team_id&quot;]),
                name=lineup[&quot;team_name&quot;],
                ground=ground_type,
                starting_formation=starting_formations[lineup[&quot;team_id&quot;]],
            )
            team.players = [
                Player(
                    player_id=str(player[&quot;player_id&quot;]),
                    team=team,
                    name=player[&quot;player_name&quot;],
                    jersey_no=int(player[&quot;jersey_number&quot;]),
                    starting=str(player[&quot;player_id&quot;]) in player_positions,
                    position=player_positions.get(str(player[&quot;player_id&quot;])),
                )
                for player in lineup[&quot;lineup&quot;]
            ]
            return team
</code></pre>
<p>循环引用有什么后果不多讨论，单从使用上来说，需要先创建 team，然后创建 player，把 team 塞到 player，再把 player 塞到 team。</p>
<p>在使用那么久之后，我还是想自己创建一个 Events 的数据格式，便写了 that-game。</p>
<p>我中和了上面两个库的特性，以及长期的使用习惯，that-game 需要有以下的特点：</p>
<ul>
<li>创建简单</li>
<li>方便计算</li>
<li>尽可能的扁平化</li>
<li>支持数据验证</li>
<li>支持类型推断</li>
<li>预设常用的数据源读取</li>
<li>方便导出为常用格式</li>
<li>方便不同的数据规格（主要是坐标）转换</li>
<li>兼容尽可能多的事件类型</li>
<li>方便不同数据源之间匹配和融合</li>
<li>可读性</li>
</ul>
<p>使用 pydantic 来创建数据类可以解决大部分，常用状态使用 typing.Literal 预设字段，既能很好的配合编辑器补全，也能通过 pydantic 进行输入验证。</p>
<p>在创建新对象的时候，可以导入每个数据类，嫌麻烦也可以这样：</p>
<pre><code class="language-python">from that_game import Shot

shot = Shot(
    id=&quot;0001&quot;,
    type=&quot;shot&quot;,
    period=&quot;first_half&quot;,
    seconds=62.0,
    team={&quot;id&quot;: &quot;ars&quot;, &quot;name&quot;: &quot;Arsenal&quot;},
    player={&quot;id&quot;: &quot;a7&quot;, &quot;name&quot;: &quot;Bukayo Saka&quot;, &quot;position&quot;: &quot;FW&quot;},
    location={
        &quot;x&quot;: 100.1,
        &quot;y&quot;: 43.2,
        &quot;pitch&quot;: {&quot;length&quot;: 108, &quot;width&quot;: 68},
    },
    end_location={
        &quot;x&quot;: 108.0,
        &quot;y&quot;: 43.2,
        &quot;pitch&quot;: {&quot;length&quot;: 108, &quot;width&quot;: 68},
    },
    pattern=&quot;open_play&quot;,
    body_part=&quot;left_foot&quot;,
    result=&quot;saved&quot;,
)
</code></pre>
<p>每个数据源之间最大的差异便是坐标系统，使用球场长宽高不同，方向不同，如何方便的转换是一个很大的问题，that-game 的 Location 可以很直观方便的转换：</p>
<pre><code class="language-python">from that_game import Location, Pitch

location = Location(
    x=0.4,
    y=0.6,
    pitch=Pitch(length=1, width=1),
)

# 只需要设定好新的 pitch 标准
pitch = Pitch(
    length=100,
    width=100,
    length_direction=&quot;left&quot;,
    width_direction=&quot;down&quot;,
)
location.transform(pitch)
print(location.x, location.y)
</code></pre>
<pre><code>60.0 40.0
</code></pre>
<p>我会在完善 Location 类后添加更多的预设 pitch，更加方便转换。</p>
<p>目前支持的 type 仅有 shot 和 pass，支持的数据源也仅是 statsbomb，同时还有一个 fusion-events 的调试项目，在这里可以通过网络请求获取一些网站，比如 understat 的 events 进行操作。之后的工作重点便是添加更多的事件类型，添加更多的事件状态，添加更多的字段，比如 shot 预设计算 distance 和 angle, 以及不断调整它们之间的兼容性，更多的 loaders。这个库的难点不在于复杂度，而在于取舍，和更方便的使用。大概会用一年的时间让他变得可用吧。</p>

    </content>
  </entry>
  <entry>
    <title>open-data events 文档笔记</title>
    <link href="https://tanzhijian.org/posts/ope_data_events"></link>
    <id>1719315575.7717075</id>
    <updated>2024-06-25T19:39:35Z</updated>
    <published>2024-06-25T19:39:35Z</published>
    <author><name>tanzhijian</name></author>
    <summary>原文档 pdf 不方便查阅特做整理, 机器翻译手动整理结构
</summary>
    <content type="html">
      <h1>open-data events 文档笔记</h1>
<p>原文档 pdf 不方便查阅特做整理, 机器翻译手动整理结构</p>
<p>v4.0</p>
<p>本文档描述了StatsBomb开放事件数据的JSON格式。</p>
<h2>Format</h2>
<p>data/events 目录中的比赛文件将采用 JSON 格式。文件名将采用 1234.json 格式，其中 1234 是比赛 ID。内容是一个包含两支球队的事件信息的数组。一些元素有子元素（通常是名称/ID 对）或子数组（这些将在文档后面详细介绍）。</p>
<ul>
<li>
<p>id: uuid, 每个事件的唯一标识符</p>
</li>
<li>
<p>index: int, 每场比赛中事件排序的序列符号。自增的整数</p>
</li>
<li>
<p>preiod: int, 时间戳对应的比赛部分</p>
<ul>
<li>1: 1st Half</li>
<li>2: 2nd Half</li>
<li>3: 3rd Period</li>
<li>4: 4th Period</li>
<li>5: Penalty Shootout</li>
</ul>
</li>
<li>
<p>timestamp: timestamp, 比赛中事件发生的时间，精确到毫秒。</p>
</li>
<li>
<p>minute: int, 事件发生时时钟上的分钟数。半场结束时重置为 45 分钟，加时赛开始时重置为 90 分钟。</p>
</li>
<li>
<p>second: int, timestamp 的第二部分</p>
</li>
<li>
<p>type: object, (id: int, name: str), event 事件类型的 ID/名称。</p>
<ul>
<li>42, Ball Receipt, 接到传球</li>
<li>2, Ball Recovery, 尝试夺回球权</li>
<li>3, Dispossessed, 球员被防守球员拦截而带球失败，因此丢失球权</li>
<li>4, Duel, 比赛中对立双方两名球员之间 50 对 50 的较量</li>
<li>5, Camera On, 发出信号停止摄像机捕捉比赛过程以进行重播/视频剪辑</li>
<li>6, Block, 站在球的路径上阻挡球</li>
<li>8, Offside, 越位。由射门或解围（非传球）导致的事件。对于造成越位的传球，请查看传球部分</li>
<li>9, Clearance, 防守球员为消除危险而采取的行动，并非有意将球传给队友</li>
<li>10, Interception, 通过移动到传球路线/做出反应进行拦截，阻止对手的传球到达队友手中</li>
<li>14, Dribble, 球员试图带球突破对手</li>
<li>16, Shot, 用身体任何（合法）部位试图进球</li>
<li>17, Pressure, 对接球、带球或传球的对方球员施加压迫</li>
<li>18, Half Start, 裁判吹哨开始一个部分的比赛</li>
<li>19, Substitution</li>
<li>20, Own Goal Against, 对方球员的乌龙球</li>
<li>21, Foul Won, 犯规获胜的定义是，一名球员在遭到对方球员犯规后，为本队赢得任意球或点球</li>
<li>22, Foul Committed, 任何被裁判判为犯规的违规行为, 越位不被视为犯规</li>
<li>23, Goal Keeper, 守门员可以执行的动作</li>
<li>24, Bad Behaviour, 当球员由于比赛之外的违规行为而收到黄牌时</li>
<li>25, Own Goal For, 该队进了一粒乌龙球</li>
<li>26, Player On, 球员离开事件发生后，球员返回球场</li>
<li>27, Player Off, 一名球员未经替换就离开/被抬出球场</li>
<li>28, Shield, 球员保护出界的球以防止对手继续比赛</li>
<li>30, Pass, 球在队友之间传递</li>
<li>33, 50/50, 两名球员争夺无球权的球</li>
<li>34, Half End, 向裁判发出哨声，表示某一场比赛部分结束</li>
<li>35, Starting XI, 标明首发 11 名球员、他们的位置以及球队阵型</li>
<li>36, Tactical Shift, 表示球队的战术变化，显示球员的新位置和球队的新阵型</li>
<li>37, Error, 当一名球员被判定犯下控球失误，从而导致射门时</li>
<li>38, Miscontrol, 球员因触球失误丢球</li>
<li>39, Dribbled Past, 球员被对手带球突破</li>
<li>40, Injury Stoppage, 因受伤而停止比赛</li>
<li>41, Referee Ball-Drop, 因伤病暂停后，裁判放下球，继续比赛</li>
<li>43, Carry, 球员在移动或站立时控制脚下的球</li>
</ul>
</li>
<li>
<p>possession: int, 表示比赛中当前唯一的一次控球。一次控球表示在比赛期间，球处于比赛状态，并且由一支球队控制球</p>
</li>
<li>
<p>possession_team: object, (id: int), 开始控球的球队的 ID。请注意，即使在控球期间试图铲球等对手事件中，此 ID 也会显示</p>
</li>
<li>
<p>play_pattern: object, (id: int, name: str), 与此事件相关的比赛模式的 ID/名称</p>
<ul>
<li>1, Regular Play, 该事件不属于以下任何 play_patterns</li>
<li>2, From Corner, 该事件是角球之后比赛进程的一部分</li>
<li>3, From Free Kick, 该事件是任意球之后比赛过程的一部分</li>
<li>4, From Throw In, 此事件是界外球之后比赛过程的一部分</li>
<li>5, Other</li>
<li>
6, From Counter 该事件是反击的一部分:<ul>
<li>控球开始于反击球队最后三分之一区域外的一次常规比赛失误</li>
<li>控球至少有 75% 直接朝向球门（以我们的控球链指标衡量）</li>
<li>反击向球门前进了至少 18 码。</li>
<li>此定义不是收集的一部分，而是从上述逻辑中得出的</li>
</ul>
</li>
<li>7, From Goal Kick, 该事件是球门球后比赛过程的一部分</li>
<li>8, From Keeper, 这一事件是守门员开球后比赛进程的一部分</li>
<li>9, From Kick Off, 该事件是开球后比赛进程的一部分</li>
</ul>
</li>
<li>
<p>team: object, (id: int, name: str), 此事件所关联的球队的 ID/名称。仅当事件与特定球队相关时，才会显示对象</p>
</li>
<li>
<p>player: object, (id: int, name: str), 与该事件相关的球员的 ID/名称（仅当事件与特定球员相关时才会显示对象）</p>
</li>
<li>
<p>position: object, (id: int, name: str), 事件发生时球员所处位置的 ID / 名称</p>
<ul>
<li>1, GK, Goalkeeper</li>
<li>2, RB, Right Back</li>
<li>3, RCB, Right Center Back</li>
<li>4, CB, Center Back</li>
<li>5, LCB, Left Center Back</li>
<li>6, LB. Left Back</li>
<li>7, RWB, Right Wing Back</li>
<li>8, LWB, Left Wing Back</li>
<li>9, RDM, Right Defensive Midfield</li>
<li>10, CDM, Center Defensive Midfield</li>
<li>11, LDM, Left Defensive Midfield</li>
<li>12, RM, Right Midfield</li>
<li>13, RCM, Right Center Midfield</li>
<li>14, CM, Center Midfield</li>
<li>15, LCM, Left Center Midfield</li>
<li>16, LM, Left Midfield</li>
<li>17, RW, Right Wing</li>
<li>18, RAM, Right Attacking Midfield</li>
<li>19, CAM, Center Attacking Midfield</li>
<li>20, LAM, Left Attacking Midfield</li>
<li>21, LW, Left Wing</li>
<li>22, RCF, Right Center Forward</li>
<li>23, ST, Striker</li>
<li>24, LCF, Left Center Forward</li>
<li>25, SS, Sencondary Striker</li>
</ul>
</li>
<li>
<p>location: array, (x: int, y: int), 包含两个整数值的数组。这些是事件的 x 和 y 坐标（仅当事件具有高度坐标时才显示）</p>
</li>
<li>
<p>duration: float, 如果相关，则事件持续的时间（以秒为单位）</p>
</li>
<li>
<p>under_pressure: bool, 该动作是在对手施加压力的情况下做出的</p>
</li>
<li>
<p>off_camera: bool: 事件发生时，摄像机处于关闭状态</p>
</li>
<li>
<p>out, bool, 如果事件的结果是球出界，则添加</p>
</li>
<li>
<p>related_events: <code>array[uuid]</code>, 相关事件 ID 的逗号分隔列表。例如，射门可能与守门员事件和拦截事件相关。相应事件的 related_events 列中将包含射门的 ID</p>
</li>
<li>
<p>tactics: object</p>
<ul>
<li>formation: int, 对于“首发 XI 或战术换班”类型的事件，添加了“战术”对象。阵型项目描述了正在使用的阵型, 433</li>
<li>lineup: <code>array[player: object[id: int, name: str], position: object[id: int, name: str], jersey_number: int]</code>, 对于“首发 XI 或战术换人”类型的事件，添加了“战术”对象。阵容项描述了球员及其位置</li>
</ul>
</li>
</ul>
<h2>Event Type Objects</h2>
<p>如果事件属于具有附加详细信息的类型，则这些详细信息将嵌套在以该事件类型命名的对象中。例如，Shot 类型的事件将具有嵌套数据框，其中包含描述该事件类型的附加变量。以下是按字母顺序排列的嵌套数据框列表及其包含的变量。</p>
<ul>
<li>
<p>50-50</p>
<ul>
<li>
outcome: object, (id: int, name: str), 50 50争夺结果的ID/名称, values:<ul>
<li>108, Won</li>
<li>109, Lost</li>
<li>147, Success To Team, 球员赢得 50/50 并将球控制到己方</li>
<li>148, Success To Opposition, 球员赢得 50/50，但将球踢到对方</li>
</ul>
</li>
<li>counterpress: bool, 在 open play 转换后 5 秒内采取压迫</li>
</ul>
</li>
<li>
<p>Bad Behaviour: object, (id: int, name: str), 红黄牌的 ID/名称</p>
<ul>
<li>65, Yellow Card</li>
<li>66, Second Yellow</li>
<li>67, Red Card</li>
</ul>
</li>
<li>
<p>Ball Receipt: object, (id: int, name: str), 指定球接收结果的属性选项的 ID/名称</p>
<ul>
<li>9, Incomplete</li>
</ul>
</li>
<li>
<p>Ball Recovery
offensive: bool, 如果恢复进攻则添加
recovery_failure: bool: 如果恢复失败则添加</p>
</li>
<li>
<p>Block</p>
<ul>
<li>deflection: bool, 如果是偏转则添加</li>
<li>offensive: bool, 如果该阻挡具有攻击性则添加</li>
<li>save_block: bool, 如果阻挡了射门则添加</li>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Carry</p>
<ul>
<li>end_location: array, (x: int, y: int)</li>
</ul>
</li>
<li>
<p>Clearance</p>
<ul>
<li>aerial_won: bool, 如果高空解围则添加</li>
<li>
body_part: object, (id: int, name: str), 触球身体部位的 ID/名称<ul>
<li>37, Head</li>
<li>38, Left Foot</li>
<li>40, Right Foot</li>
<li>70, Other</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dribble</p>
<ul>
<li>Overrun: bool, 当球越过原来的防守队员进入另一名球员的球权时添加</li>
<li>Nutmeg: bool, 当球从对方球员腿间穿过时添加</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>8, Complete</li>
<li>9, Incomplete</li>
</ul>
</li>
<li>No Touch: bool, 如果球员试图通过将球漏过对手而不是接触球来进行带球</li>
</ul>
</li>
<li>
<p>Dribbled Past</p>
<ul>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Duel</p>
<ul>
<li>counterpress: bool</li>
<li>
type: object, (id: int, name: str), Id/Name 为对抗的类型<ul>
<li>10, Aerial Lost, 争夺空中对抗但没能抢到球</li>
<li>11, Tackle, 抢断对方球员的控球权</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str), 对抗结果的 Id/名称<ul>
<li>1， Lost</li>
<li>4, Won, 抢断最终落入抢断队员手中</li>
<li>13, Lost In Play, 将球踢向对手的抢断</li>
<li>14, Lost Out, 铲球将球击出界外，有利于对手</li>
<li>15, Success</li>
<li>16, Success In Play, 将球传给队友的抢断</li>
<li>17， Success Out, 抢断将球击出界外，有利于抢断者的球队</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Foul Committed</p>
<ul>
<li>counterpress: bool</li>
<li>offensive: bool</li>
<li>
type: object, (id: int, name: str), Id/Name 为犯规的类型<ul>
<li>19, 6 Seconds, 因 6 秒违例被判犯规</li>
<li>20, Backpass Pick, 因回传用手接球违例被判犯规</li>
<li>21, Dangerous Play, 危险动作导致犯规</li>
<li>22, Dive, 因假摔而犯规</li>
<li>23, Foul Out, 因犯规被罚出场</li>
<li>24, Handball, 手球犯规</li>
</ul>
</li>
<li>advantage: bool, 如果裁判判定为进攻有利比赛继续则添加</li>
<li>penalty: bool, 如果被判点球添加</li>
<li>
card: object, (id: int, name: str), 卡牌的类型<ul>
<li>5, Yellow Card</li>
<li>6, Second Yellow</li>
<li>7, Red Card</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Foul Won</p>
<ul>
<li>defensive: bool, 如果在失去控球权的情况下犯规，则添加</li>
<li>advantage: bool, 如果裁判判定为进攻有利比赛继续则添加</li>
<li>penalty: bool, 如果判罚点球则添加</li>
</ul>
</li>
<li>
<p>GoalKeeper</p>
<ul>
<li>
position: object, (id: int, name: str), 守门员射门前站位选项的 ID/名称<ul>
<li>42, Moving, 射门时守门员正在移动</li>
<li>43, Prone, 射门时守门员倒在地上</li>
<li>44, Set, 射门时守门员处于静止状态</li>
</ul>
</li>
<li>
technique: object, (id: int, name: str), 守门员使用的技术技术选项的 ID/名称<ul>
<li>45, Diving, 守门员飞身进行扑救</li>
<li>46, Standing, 守门员站立进行扑救</li>
</ul>
</li>
<li>
body_part: object, (id: int, name: str), 守门员扑救时使用的身体部位<ul>
<li>35, Both Hands</li>
<li>36, Chest</li>
<li>37, Head</li>
<li>38, Left Foot</li>
<li>39, Left Hand</li>
<li>40, Right Foot</li>
<li>41, Right Hand</li>
</ul>
</li>
<li>
type: object, (id: int, name: str), 指定守门员事件类型的 ID/名称。每次射门都会有一个相关的守门员事件。如果没有失球或没有扑救，守门员类型将为“Shot Faced”）<ul>
<li>25, Collected</li>
<li>26, Goal Conceded, 失球</li>
<li>27, Keeper Sweeper, 当守门员离开自己的防线和/或禁区扑球时</li>
<li>28, Penalty Conceded, 守门员在点球中失球</li>
<li>29, Penalty Saved</li>
<li>30, Punch, 守门员拳击球（类似清球）</li>
<li>31, Save, 守门员扑救非射门</li>
<li>32, Shot Faced, 射门未导致扑救或失球</li>
<li>33, Shot Saved, 守门员扑出对方射门</li>
<li>34, Smother, 相当于禁区外球员的抢断，守门员出来抢断球员</li>
<li>113, Shot Saved Off T, 守门员扑出了对方偏离目标的射门</li>
<li>114, Shot Saved To Post, 射门被守门员扑出，击中门柱</li>
<li>110, Saved To Post, 守门员扑救非射门击中门柱</li>
<li>109, Penalty Saved To Post</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>47, Claim, 守门员清道夫动作，但是接住了球</li>
<li>48, Clear, 守门员清道夫动作，但是清除了球</li>
<li>49, Collected Twice, 守门员在第一次接球失误后，又多次尝试接球</li>
<li>50, Fail, 动作失败</li>
<li>51, In Play, 守门员扑救，将球挡回场内</li>
<li>52, In Play Danger, 守门员扑救，将球挡给对方球员</li>
<li>53, In Play Safe, 守门员扑救，将球挡给队友</li>
<li>55, No Touch, 守门员未触球就丢球</li>
<li>56, Saved Twice, 守门员在第一次扑救失败后，又多次尝试扑救</li>
<li>15, Success</li>
<li>58, Touched In, 尽管守门员触球，但还是丢球</li>
<li>59, Touched Out, 守门员触球出界</li>
<li>4, Won, 获得球权</li>
<li>16, Success In Play, 将球传给队友的扑救</li>
<li>17, Success Out, 将球扑出界外，有利于拦截方的球队</li>
<li>13， Lost In Play, 将球击向对手的扑救</li>
<li>14, Lost Out, 将球击出界外，有利于对手</li>
<li>117, Punched Out, 守门员将球扑出界外</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Half End</p>
<ul>
<li>Early Video End: bool, 如果比赛视频不完整且比赛在本节结束前结束，则添加</li>
<li>Match Suspended: bool, 裁判决定结束或推迟比赛</li>
</ul>
</li>
<li>
<p>Half Start</p>
<ul>
<li>Late Video Start: bool, 如果比赛视频未完成并在开球后开始，则添加</li>
</ul>
</li>
<li>
<p>Injury Stoppage</p>
<ul>
<li>in_chain: bool, 如果比赛暂停前球在受伤球员的球队手中，则添加</li>
</ul>
</li>
<li>
<p>Interception</p>
<ul>
<li>
outcome, object, (id: int, name: str)<ul>
<li>1, Lost</li>
<li>13, Lost In Play, 将球击给对手的拦截</li>
<li>14, Lost Out, 拦截将球击出界外，有利于对方</li>
<li>15, Success</li>
<li>16, Success In Play, 将球传给队友的拦截</li>
<li>17, Success Out, 拦截将球击出界外，有利于拦截方的球队</li>
<li>4, Won, 拦截后球落入拦截者手中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Miscontrol</p>
<ul>
<li>aerial_won: bool, 如果事件发生在空中，则添加</li>
</ul>
</li>
<li>
<p>Pass</p>
<ul>
<li>recipient: object, (id: int, name: str), Id / Name 传球接收者的球员，或未完成传球的接收者的球员</li>
<li>length: float, 以码为单位的传球长度, 16.03</li>
<li>angle: float, 以弧度表示的通过角度，其中 0 指向正前方，0 到 π 之间的正值表示顺时针方向的角度，0 到 -π 之间的负值表示逆时针方向的角度, -2.49</li>
<li>
height: object, (id: int, name: str), 传球高度的 ID / 名称<ul>
<li>1, Ground Pass, 球没有离开地面</li>
<li>2, Low Pass, 球离开地面但在最高高度时低于肩膀的高度</li>
<li>3, High Pass, 球在最高高度超过肩膀的高度</li>
</ul>
</li>
<li>end_location: array, (x: int, y: int)</li>
<li>assisted_shot_id: uuid, 如果这次传球是助攻，那么关联射门的事件 id</li>
<li>backheel: bool, 如果用脚后跟传球则添加</li>
<li>deflected: bool, 如果传球偏转则添加</li>
<li>miscommunication: bool, 如果传球存在沟通不畅则添加</li>
<li>cross: bool, 如果传球是传中则添加</li>
<li>cut-back: bool, 如果传球是回传则添加</li>
<li>switch: bool, 如果传球是转移（球垂直转移了至少 50% 的球场），则添加</li>
<li>shot-assist: bool, 如果传球是对射门的助攻（但未进球），则添加</li>
<li>goal-assist: bool, 如果传球助攻进球，则添加</li>
<li>
body-part: object, (id: int, name: str)<ul>
<li>68, Drop Kick, 传球来自守门员的 drop kick</li>
<li>37, Head, 传球来自头球</li>
<li>69, Keeper Arm, 传球来自守门员的手手抛球</li>
<li>38, Left Foot</li>
<li>70, Other</li>
<li>40, Right Foot</li>
<li>106, No Touch, 一名球员故意让球从自己身边经过，而不是接球，而是传给身后的队友。也称为“假动作”）。</li>
</ul>
</li>
<li>
type: object, (id: int, name: str)<ul>
<li>61, Corner</li>
<li>62, Free Kick</li>
<li>63, Goal Kick</li>
<li>64, Interception</li>
<li>65, Kick Off, 比赛开始时或得分后开球时的传球</li>
<li>66, Recovery, 一触式传球抢断</li>
<li>67, Throw-in</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>9, Incomplete, 球未到达队友，比赛仍在进行中</li>
<li>74, Injury Clearance, 因受伤而停止比赛，球出界</li>
<li>75, Out, 球出界</li>
<li>76, Pass Offside, 球传到队友手中但传球被判越位</li>
<li>77, Unknown, 结果未知（即在飞行过程中被判犯规）</li>
</ul>
</li>
<li>
Technique: object, (id: int, name: str), 传球技术的 ID / 名称<ul>
<li>104, Inswinging, 适用于内旋高/低角球</li>
<li>105, Outswinging, 适用于外旋高/低角球</li>
<li>107, Straight, 不适用于内旋角球或外旋角球</li>
<li>108, Through Ball, 传球突破最后一道防线</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Player Off</p>
<ul>
<li>Permanent: bool, 如果球员永久离开比赛，则添加。适用于没有替补球员但球员因伤无法重返球场的情况</li>
</ul>
</li>
<li>
<p>Pressure</p>
<ul>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Shot</p>
<ul>
<li>key_pass_id: uuid</li>
<li>end_location: array, (x: int, y: int)</li>
<li>aerial_won: bool, 如果射门是空中胜利，则添加</li>
<li>follows_dribble: bool, 如果射门是在盘带后进行的，则添加</li>
<li>first_time: bool, 如果射门是第一次触球，则添加</li>
<li>freeze_frame: array, 每次射门都包含一个名为 freeze_frame 的对象，该对象是一个数组，其中包含射门时相关球员的信息，每个 freezeframe 对象都是一个数据框，每个球员占一行，包括他们的位置、球队、ID、姓名以及位置 ID 和姓名</li>
<li>open_goal: bool, 如果射门是在空门的情况下进行的，则添加</li>
<li>statsbomb_xg: float</li>
<li>deflected: bool, 如果射门偏出则添加</li>
<li>
technique: object, (id: int, name: str), 射门技术的 ID / 名称<ul>
<li>89, Backheel</li>
<li>90, Diving Header</li>
<li>91, Half Volley, 半临空</li>
<li>92, Lob, 为了越过对方球员而射出的球具有较高的弧线</li>
<li>93, Normal, 不属于任何其他技术的射门</li>
<li>94, Overhead Kick</li>
<li>95, Volley</li>
</ul>
</li>
<li>
body_part: object, (id: int, name: str)<ul>
<li>37, Head</li>
<li>38, Laft Foot</li>
<li>70, Other</li>
<li>40, Right Foot</li>
</ul>
</li>
<li>
type: object, (id: int, name: str)<ul>
<li>61, Corner</li>
<li>62, Free Kick</li>
<li>87, Open Play</li>
<li>88, Penalty</li>
<li>65, Kick Off, 开球后直接射门</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>96, Blocked</li>
<li>97, Goal</li>
<li>98, Off T</li>
<li>99, Post</li>
<li>100, Saved</li>
<li>101, Wayward, 射门毫无威胁，偏离球门太远或力量不足以到达球门线（或球员没有碰到球的失误）</li>
<li>115, Saved Off T</li>
<li>116, Saved To Post</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Substitution</p>
<ul>
<li>replacement: object, (id: int, name: str), 对于替换，上场球员的 ID/姓名。球员详情（主要事件）描述下场球员。</li>
<li>
outcome: object, (id: int, name: str), 替换类型选项的 Id/Name<ul>
<li>102, Injury</li>
<li>103, Tactical</li>
</ul>
</li>
</ul>
</li>
</ul>

    </content>
  </entry>
  <entry>
    <title>我所设想的 fusion-stat 数据模型</title>
    <link href="https://tanzhijian.org/posts/fusion-stat-model-refactoring-ideas"></link>
    <id>1712469841.6559868</id>
    <updated>2024-04-07T14:04:01Z</updated>
    <published>2024-04-07T14:04:01Z</published>
    <author><name>tanzhijian</name></author>
    <summary>目前 fusion-stat 模型总共分为 Competitions, Competition, Team, Staff, Player, Matches, Match, 他们之间自成一派，并没有什么关联，且最大的问题是数据规则是写死的，即开发者制定了所有的规则，用户能修改或定制的部分很少，要么便是自己 import spiders 来重写。
</summary>
    <content type="html">
      <h1>我所设想的 fusion-stat 数据模型</h1>
<p>目前 fusion-stat 模型总共分为 Competitions, Competition, Team, Staff, Player, Matches, Match, 他们之间自成一派，并没有什么关联，且最大的问题是数据规则是写死的，即开发者制定了所有的规则，用户能修改或定制的部分很少，要么便是自己 import spiders 来重写。</p>
<p>我的设想是统一数据模型。目前为止每个爬虫子模块里面的 item 都是单独定义，很灵活，但当你需要从其他地方导入的时候就不是很优雅，比如会出现大段大段的 <code>spiders.transfermarkt.competition.Item</code> 这样的字段，统一设计数据模型之后，就可以从 models 里面导入。</p>
<p>大概思路是这样，以 competition 作为例子：</p>
<pre><code class="language-python">class Stat:
    def __init__(
        self,
        id: str,
        name: str,
        **fields: typing.Any,
    ) -&gt; None:
        self.id = id
        self.name = name
        self.fields = fields


class Competition(Stat):
    def __init__(
        self,
        id: str,
        name: str,
        country_code: str,
        teams: list[&#x27;Team&#x27;] | None = None,
        matches: list[&#x27;Match&#x27;] | None = None,
    ) -&gt; None:
        super().__init__(id, name)
        self.country_code = country_code
        if teams is None:
            teams = []
        self.teams = teams
        if matches is None:
            matches = []
        self.matches = matches
</code></pre>
<p>每个爬虫子模块的 Competition Item 从父类继承，只要满足父类对于 Competition 定义的字段即可，每个爬虫的特殊字段都塞到 fields 中，至于数据结构，是类还是 dict，又或者其他再讨论。待到从每个爬虫模块收集的数据完毕之后，他们的合并方式，统一在每个类中实现一些 merge 方法，定义了合并之后字段处理的规则，然后再实现 <code>add</code> 方法，每两个数据类结果想要相加，直接调用方法即可，类似于 <code>competition1.add(competition2)</code>，甚至可以实现 <code>__add__</code> 通过运算符操作</p>
<pre><code class="language-python">def add(self, new: &#x27;Competition&#x27;) -&gt; &#x27;Competition&#x27;:
    teams = self._merge_teams(new.teams)
    matches = self._merge_matches(new.matches)
    fields = self.fields | new.fields
    return Competition(
        id=self.id,
        name=self.name,
        country_code=self.country_code,
        teams=teams,
        matches=matches,
        **fields,
    )

def _merge_teams(
    self,
    news: typing.Sequence[&#x27;Team&#x27;],
) -&gt; list[&#x27;Team&#x27;]:
    results: list[&#x27;Team&#x27;] = []
    for query in self.teams:
        selected = process.extractOne(
            query,
            news,
            processor=lambda x: x.name,
        )
        result = selected[0]
        results.append(query.add(result))
    return results

def _merge_matches(
    self,
    news: typing.Sequence[&#x27;Match&#x27;],
) -&gt; list[&#x27;Match&#x27;]:
    ...
</code></pre>
<p>开发者可以任意调整预先要用到的数据类，把他们 add 到一起，比起现版本</p>
<pre><code class="language-python">class Competition:
    def __init__(
        self,
        fotmob: spiders.fotmob.competition.Item,
        fbref: spiders.fbref.competition.Item,
        official: spiders.official.competition.Item,
        transfermarkt: spiders.transfermarkt.competition.Item,
    ) -&gt; None:
        self._fotmob = fotmob
        self._fbref = fbref
        self._official = official
        self._transfermarkt = transfermarkt
</code></pre>
<p>这样的形式优雅很多，然后定义数据规则方法，提供 api。</p>
<p>如果用户不认同这些规则，也可以自己 add，比起现版本也会方便很多。</p>

    </content>
  </entry>
  <entry>
    <title>fusion-stat 能否使用可读性 id</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_id_explore"></link>
    <id>1709042090.1353555</id>
    <updated>2024-02-27T21:54:50Z</updated>
    <published>2024-02-27T21:54:50Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 的 0.0.6 版本更新计划中曾有一项是所有的 id 具有可读性，在我看来是一项能很大提升使用体验的特性，目前的主流数据应用中，都是采用随机或顺序生成的 "id" 类型的 id，比如 Arsenal, fotmob 是 9825, fbref 是 18bb7c10，transfermarkt 是 11。这反映在 url 查询中则是 https://fbref.com/en/squads/18bb7c10/Arsenal-Stats, https://www.transfermarkt.com/fc-arsenal/startseite/verein/11, 虽说添加了名字在 url 中提升可读性，但名字并不是查询的必要条件，真正的查询是通过 id，所以如果能在 id 中实现既有唯一性，又有可读性，就能很好的改善，甚至还可以拼写出 id。
</summary>
    <content type="html">
      <h1>fusion-stat 能否使用可读性 id</h1>
<p>fusion-stat 的 0.0.6 版本更新计划中曾有一项是所有的 id 具有可读性，在我看来是一项能很大提升使用体验的特性，目前的主流数据应用中，都是采用随机或顺序生成的 &quot;id&quot; 类型的 id，比如 Arsenal, fotmob 是 9825, fbref 是 18bb7c10，transfermarkt 是 11。这反映在 url 查询中则是 https://fbref.com/en/squads/18bb7c10/Arsenal-Stats, https://www.transfermarkt.com/fc-arsenal/startseite/verein/11, 虽说添加了名字在 url 中提升可读性，但名字并不是查询的必要条件，真正的查询是通过 id，所以如果能在 id 中实现既有唯一性，又有可读性，就能很好的改善，甚至还可以拼写出 id。</p>
<p>要实现这样的 id，需要探讨两个问题，第一，能不能设计出设计出这样的 id，第二，能不能在 fusion-stat 中顺利实装。</p>
<p>fusion-stat 目前模型以及相互关系是这样的：</p>
<pre><code class="language-python">class Competition:
    teams: list[Team]
    matches: list[Match]


class Team:
    staffs: list[Staff]
    players: list[Player]


class Staff:
    team: Team
    competition: Competition


class Player:
    team: Team
    competition: Competition


class Match:
    competition: Competition
    home: Team
    away: Team
</code></pre>
<p>而要考虑的因素：</p>
<ol>
<li>唯一</li>
<li>可读</li>
<li>尽可能的固定</li>
<li>相互关系中的一致</li>
</ol>
<p>首先是 competition, 赛事的名字不具有唯一性，比如在 fotmob 搜索 Premier League, 会得到 10 个以上的结果，但通常在一个足协单位内，赛事名称是具有唯一性的，比如英格兰的赛事就只有一个 Premier League，使用赛事名字和地区的组合便可用作 competition 的 id，ENG_Premier-League 这样的字符串具有可读性，而赛事名字和赛事地区都是很容易获取的特征，相互关系的一致也能保证。</p>
<p>然后是 team，与 competition 一样，这个世界上可能会有几个 Arsenel，但英格兰内只有一个 Arsenal，所以采用 ENG_Arsenal 这样的字符串作为 id 也是可行的。</p>
<p>接下来是 staff 和 player，名字不具有唯一性，所属俱乐部随着转会经常会变，甚至国籍也有可能更换。出生地是个不错的特征，但通常不能在 team 的数据源内找到，从而无法保证上下文一致，所以能采用的是名字 + 生日，比如 2001-09-05_Bukayo-Saka，同一天生日的人是否具有同名，放在世界范围内可能有很多，但放在球员里面可能就是很小概率的事件了，暂且把它当作可行。</p>
<p>最后是 match, 比赛日期 + 主队 + 客队名字，比如 2023-09-03_Crystal_Palace_vs_Wolverhampton_Wanderers, 和上面 team 讨论的一样，可能会 or, 但是 and 的概率很小，可以当作可行。</p>
<p>下面就是添加到 fusion-stat。country_name 和 country_code 各个数据源使用不一致，在写了 fifacodes 之后可以很好的解决。</p>
<p>后面的工作就没那么好进行下去了，上一级获取下一级的数据可以做到，最主要还是卡在了如何在下一级的数据中获取到上一级一致的特征。比如在 match 中需要获取 competition 和 team 所有的 id 特征，名字是基本特征容易获取到，但国家在目前的数据源内并不能找全，诚然目前可以把 competition 的国家用在 team，但之后添加了洲际比赛，世界级比赛，国家队比赛，这些就没办法使用了。</p>
<p>最终还是放弃了在 0.0.6 版本中更新 id，有可行性，但以目前的数据广度还不能实装，且 player 级的唯一性还需进一步优化，只能在未来不断扩展新的数据源中重点考虑这些特征直到全部可用了。</p>

    </content>
  </entry>
  <entry>
    <title>介绍一下 fifacodes</title>
    <link href="https://tanzhijian.org/posts/fifacodes_intro"></link>
    <id>1705496359.0520616</id>
    <updated>2024-01-17T20:59:19Z</updated>
    <published>2024-01-17T20:59:19Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 的开发过程有很多国家名称和国家代码转换的场景，一些数据源是使用国家名称，另外一些使用国家代码，在使用时需要那么一个工具来统一他们。最开始打算使用 pycountry, 但对于足球数据来说大多是使用国际足联成员国的国家地区来区分，而国际足联国家代码与 ISO 3166-1 三位字母代码是有差异的，比如使用英格兰 ENG 而不是英国 GBR。搜索了一下并没有现成的工具，只能自己写一个。
</summary>
    <content type="html">
      <h1>介绍一下 fifacodes</h1>
<p>fusion-stat 的开发过程有很多国家名称和国家代码转换的场景，一些数据源是使用国家名称，另外一些使用国家代码，在使用时需要那么一个工具来统一他们。最开始打算使用 pycountry, 但对于足球数据来说大多是使用国际足联成员国的国家地区来区分，而国际足联国家代码与 ISO 3166-1 三位字母代码是有差异的，比如使用英格兰 ENG 而不是英国 GBR。搜索了一下并没有现成的工具，只能自己写一个。</p>
<p>首先是数据源，维基百科有现成的表，爬下来即可。但直接使用有个问题是，国家代码是标准的，数据源与数据源的国家名称不一定是标准的，比如我国，大多数数据源是 China，一小部分是 China PR，以至于还需要一个 custom 来添加更多的别名，所幸两百多个国际足联成员国数量并不大，有了基础数据之后，这个 custom 采用手工维护即可。</p>
<p>接下来是方法了，我的设想是，整个国家代码和名称可以抽象成一个 Counties 类，而这个类本质上是一个只读 dict，可以通过 dict 的所有方法索引查询到一个包含代码和名称的 Country 类。</p>
<p>而索引可以并不只限于代码，它的数据特殊性在于，代码是唯一的，名称是唯一的，同时代码与名称之间也是唯一的，所以可以把他们全部添加为索引，既可以用代码也可以用名称，像这样:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.get(&#x27;ENG&#x27;)
Country(code=&#x27;ENG&#x27;, name=&#x27;England&#x27;)
&gt;&gt;&gt; counties[&#x27;England&#x27;]
Country(code=&#x27;ENG&#x27;, name=&#x27;England&#x27;)
</code></pre>
<p>这样使用起来可以不论数据源是使用何种识别方式，都能很好的处理。但由于代码和名称同时在索引内，使用一些迭代方法的时候会出现重复的 value，所以最简单的方法便是使用两个 dict，使用 getitem 的方法时用 key + value 的 dict，使用 iter 时用只有 key 的 dict。</p>
<p>同时还有一个搜索方法，使用 rapidfuzz 来实现 key 的搜索，如果不确定准确的 key，输入一部分也可以获得结果：</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.search(&#x27;ARG&#x27;)
[Country(code=&#x27;ARG&#x27;, name=&#x27;Argentina&#x27;), Country(code=&#x27;AFG&#x27;, name=&#x27;Afghanistan&#x27;), Country(code=&#x27;ALG&#x27;, name=&#x27;Algeria&#x27;)]
&gt;&gt;&gt; counties.search_one(&#x27;Argent&#x27;)
Country(code=&#x27;ARG&#x27;, name=&#x27;Argentina&#x27;)
</code></pre>
<p>一些参数也是可以调节的：</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.search(&#x27;Fran&#x27;, limit=2, score_cutoff=70)
[Country(code=&#x27;FRA&#x27;, name=&#x27;France&#x27;), Country(code=&#x27;IRN&#x27;, name=&#x27;Iran&#x27;)]
</code></pre>
<p>基本功能就这些了，已经可以 pip 安装使用。</p>
<p>对于数据的更新，我的设想是默认的基础数据只通过脚本爬取维基百科进行更新，手动维护的 custom 接收 pr 提交，添加的条目代码通常不会有增加，而名称只作为别名添加到索引，返回的 value, Country 仍然使用 default 中的名称，这样比较好规范。</p>

    </content>
  </entry>
  <entry>
    <title>关于在 fusion_stat.models 中使用 shortlist 作为匹配辅助的探讨</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_shortlist"></link>
    <id>1704821742.058141</id>
    <updated>2024-01-10T01:35:42Z</updated>
    <published>2024-01-10T01:35:42Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 有一个一直让我不安的地方，就是在使用 rapidfuzz.process.extractOne 匹配时返回唯一结果的正确性，我并不确定他在扩展越来越多的数据源后能不能继续保持良好的运转，所以一直在探索一些方法解决。而今晚想到一个暂且看上去还不错，但也不是很好的，先上代码吧
</summary>
    <content type="html">
      <h1>关于在 fusion_stat.models 中使用 shortlist 作为匹配辅助的探讨</h1>
<p>fusion-stat 有一个一直让我不安的地方，就是在使用 rapidfuzz.process.extractOne 匹配时返回唯一结果的正确性，我并不确定他在扩展越来越多的数据源后能不能继续保持良好的运转，所以一直在探索一些方法解决。而今晚想到一个暂且看上去还不错，但也不是很好的，先上代码吧</p>
<pre><code class="language-python">import typing
import warnings
from abc import ABC

from rapidfuzz import fuzz, process

_S1 = typing.TypeVar(&#x27;_S1&#x27;)
_S2 = typing.TypeVar(&#x27;_S2&#x27;)


MINIMUM_SIMILARITY = 50
SIMILARITY_DIFFERENCE = 5


class BaseModel(ABC):
    def __init__(self, show_warning: bool = True) -&gt; None:
        self.show_warning = show_warning
        self._shortlist: list[typing.Any] = []

    @property
    def shortlist(self) -&gt; list[typing.Any]:
        return self._shortlist

    def extract(
        self,
        query: _S1,
        choices: list[_S2],
        scorer: typing.Callable[..., int | float] = fuzz.WRatio,
        processor: typing.Callable[..., typing.Sequence[typing.Hashable]]
        | None = None,
        score_cutoff: int | float | None = None,
    ) -&gt; _S2:
        results = process.extract(
            query,
            choices,
            scorer=scorer,
            processor=processor,
            score_cutoff=score_cutoff,
        )

        first = results[0]
        second = results[1] if len(results) &gt; 1 else None
        if first[1] &lt; MINIMUM_SIMILARITY:
            if self.show_warning:
                warnings.warn(
                    (
                        &#x27;The result similarity is less than 50%, &#x27;
                        &#x27;please check the shortlist.&#x27;
                    ),
                    SimilarityWarnings,
                )
            self._shortlist.append((query, results))
        elif (
            second is not None
            and abs(first[1] - second[1]) &lt; SIMILARITY_DIFFERENCE
        ):
            if self.show_warning:
                warnings.warn(
                    (
                        &#x27;There are results that are too similar, &#x27;
                        &#x27;please check the shortlist.&#x27;
                    ),
                    SimilarityWarnings,
                )
            self._shortlist.append((query, results))

        return results[0][0]


class SimilarityWarnings(Warning):
    pass
</code></pre>
<p>我的大致思路是每个 model 都继承 BaseModel 获得 shortlist 和 extract，extract 是对 rapidfuzz.process.extract 的扩写，基本就是通过 rapidfuzz.process.extract 先获得初步结果 results，然后再进行一系列的判定：</p>
<ul>
<li>如果最接近的结果小于 50% 则提示</li>
<li>如果最接近的两个结果过于相似也提示</li>
<li>并把所有的结果放到候选列表 shortlist</li>
<li>最终仍然会返回最接近的结果</li>
</ul>
<p>在使用 rapidfuzz.process.extractOne 的地方替换成使用 self.extract。当然了上面的代码只是一个初步的草稿，并没有考虑太多的条件，数值胡乱设一些，shortlist 也没有封装，但大致思路是，在程序一些不能很好判定的时候，把检查核对交给使用者</p>
<p>但不好的地方在于，fusion-stat 面对的足球数据源通常只有两类：每个数据源都能够一一对应的数据类型，比如赛事，参赛球队，比赛，历史数据；每个数据源不能一一对应上的数据类型，比如球员名单，一些数据源会包含二队，青年队，位置参数，每个数据源对于位置的理解是有差别；而 extractOne 基本是在匹配后一类时会出错，所以 self.extract 并不能成为一个通用方法，而是专用方法</p>
<p>另一个顾虑是，在使用 extractOne 匹配不能一一对应的数据时目前是设置了 score_cutoff 参数一刀切，最小匹配策略，而如果想在这上面优化，默认返回的匹配结果将会是一个很大的问题，因为没有达到标准，如果要返回大概率将会是一个错误的结果，而同时还需要把 shorlist 交给使用者判定，如果使用者没有注意到 shortlist 呢，或者只是想把它跑在一个自动化程序里面并不想每天去观察改动呢</p>
<p>所以原本打算在 0.0.5 使用上这个功能，但又暂时不考虑了</p>

    </content>
  </entry>
  <entry>
    <title>一些读取环境变量的探讨</title>
    <link href="https://tanzhijian.org/posts/explore_env"></link>
    <id>1704024002.7686512</id>
    <updated>2023-12-31T20:00:02Z</updated>
    <published>2023-12-31T20:00:02Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我最早使用，到现在也一直在用的包了，基本覆盖了日常使用的需求，简单，可读性也很好
</summary>
    <content type="html">
      <h1>一些读取环境变量的探讨</h1>
<h2>python-decouple</h2>
<p>我最早使用，到现在也一直在用的包了，基本覆盖了日常使用的需求，简单，可读性也很好</p>
<pre><code class="language-python">def test_decoupe_config() -&gt; None:
    foobar = config(&#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    assert config(&#x27;NUMBER&#x27;) == &#x27;1&#x27;
    assert config(&#x27;NUMBER&#x27;, cast=int) == 1

    with pytest.raises(UndefinedValueError):
        assert not config(&#x27;FOO&#x27;)

    foo = config(&#x27;FOO&#x27;, default=None)
    assert foo is None
</code></pre>
<p>但是它在一些静态工具里面会丢失类型提示，比如 pyright <code>foobar = config(&#x27;FOOBAR&#x27;)</code> 会被推断为类型 <code>bool | Unknown</code>，以至于每次要正确设置类型的时候需要 <code>foobar: str | None = config(&#x27;FOOBAR&#x27;)</code></p>
<p>它的主类 <code>def __call__(self, *args, **kwargs):</code>，也不能支持参数的补全提示</p>
<h2>python-dotenv</h2>
<p>推荐用法之一是统一调用函数 <code>load_dotenv()</code>，它的具体细节是这样：</p>
<pre><code class="language-python">def set_as_environment_variables(self) -&gt; bool:
    &quot;&quot;&quot;
    Load the current dotenv as system environment variable.
    &quot;&quot;&quot;
    if not self.dict():
        return False

    for k, v in self.dict().items():
        if k in os.environ and not self.override:
            continue
        if v is not None:
            os.environ[k] = v

    return True
</code></pre>
<p>把读取到的 .env 通过 <code>os.environ[k] = v</code> 写到环境变量，使用时 <code>os.getenv()</code> 读取即可，好处是使用逻辑比较统一，但我个人并不喜欢这样用，因为会污染到环境变量</p>
<p>不过它提供一个用来专门读取 .env 的函数 dotenv_values</p>
<pre><code class="language-python">def test_dotenv_values() -&gt; None:
    dotenv = dotenv_values(&#x27;.env&#x27;)
    foobar = dotenv[&#x27;FOOBAR&#x27;]
    assert foobar == &#x27;foobar&#x27;

    assert dotenv[&#x27;NUMBER&#x27;] == &#x27;1&#x27;

    with pytest.raises(KeyError):
        assert not dotenv[&#x27;FOO&#x27;]

    foo = dotenv.get(&#x27;FOO&#x27;)
    assert foo is None
</code></pre>
<p>默认是读取 <code>.env</code>，也可以传入其他文件名，返回值是一个 dict，使用就和操作 dict 一样，可以通过 <code>.get</code> 返回 <code>str | None</code>，也可以直接抛出 <code>KeyError</code>，很方便。还可以通过解包的形式读取多个配置以及环境变量</p>
<pre><code class="language-python">config = {
    **dotenv_values(),
    **dotenv_values(&#x27;.env.test&#x27;),
    **os.environ,
}
</code></pre>
<p>缺点是纯手动，也没有自带的类型转换，其实关系不大，无论是简单的还是复杂的转换无非就是自己多写这行代码还是通过参数传入逻辑的区别。也有单个读取 <code>get_key()</code></p>
<pre><code class="language-python">def test_dotenv_get_key() -&gt; None:
    foobar = get_key(&#x27;.env&#x27;, &#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    foo = get_key(&#x27;.env&#x27;, &#x27;FOO&#x27;)
    assert foo is None
</code></pre>
<pre><code class="language-python">def get(key: str) -&gt; str | None:
    if (value := get_key(&#x27;.env&#x27;, key)) is not None:
        return value
    return os.getenv(key)
</code></pre>
<p>缺点还是纯手动。但它依然是使用者最多的包，很适合用来在此基础上开发更多的功能</p>
<h2>pydantic-settings</h2>
<p>pydantic-settings 便是使用了 python-dotenv 支持 .env 读取</p>
<pre><code class="language-python">class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=&#x27;.env&#x27;,
        env_file_encoding=&#x27;utf-8&#x27;,
    )

    FOOBAR: str | None = None
    NUMBER: int | None = None


def test_pydantic_settings() -&gt; None:
    settings = Settings()
    assert settings.FOOBAR == &#x27;foobar&#x27;
    assert settings.NUMBER == 1
</code></pre>
<p>通过 pydantic 优秀的验证和转换，可以实现很好的类型转换。如果项目中使用了 pydantic 可以优先使用它</p>
<h2>starlette.config</h2>
<p>starlette.config 在我看来是 python-decouple 最完美的替代品了，而且它和 python-decouple 也算是渊源颇深。用法基本一致</p>
<pre><code class="language-python">def test_starlette_config() -&gt; None:
    config = Config(&#x27;.env&#x27;)
    foobar = config(&#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    assert config(&#x27;NUMBER&#x27;) == &#x27;1&#x27;
    assert config(&#x27;NUMBER&#x27;, cast=int) == 1
    assert config(&#x27;NUMBER&#x27;, cast=bool) is True

    with pytest.raises(KeyError):
        assert not config(&#x27;FOO&#x27;)

    foo = config(&#x27;FOO&#x27;, default=None)
    assert foo is None
</code></pre>
<p>类型提示，参数补全的问题被解决掉了，同时它还有一个实现的很有意思的 Secret 类用来读取敏感数据</p>
<pre><code class="language-python">class Secret:
    &quot;&quot;&quot;
    Holds a string value that should not be revealed in tracebacks etc.
    You should cast the value to `str` at the point it is required.
    &quot;&quot;&quot;

    def __init__(self, value: str):
        self._value = value

    def __repr__(self) -&gt; str:
        class_name = self.__class__.__name__
        return f&quot;{class_name}(&#x27;**********&#x27;)&quot;

    def __str__(self) -&gt; str:
        return self._value

    def __bool__(self) -&gt; bool:
        return bool(self._value)
</code></pre>
<pre><code class="language-python">def test_starlette_config_secret() -&gt; None:
    config = Config(&#x27;.env&#x27;)
    secret = config(&#x27;FOOBAR&#x27;, cast=Secret)
    assert repr(secret) == &quot;Secret(&#x27;**********&#x27;)&quot;
    assert str(secret) == &#x27;foobar&#x27;
</code></pre>
<p>没有用加密手段却规避了在调试时的信息泄露。但它的不方便之处在于，不可能为了只使用而安装整个 Starlette。于是大多数时候都是用 python-dotenv 自己写一个读取的类</p>

    </content>
  </entry>
  
</feed>