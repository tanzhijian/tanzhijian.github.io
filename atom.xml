<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tanzhijian.org</title>
  <id>https://tanzhijian.org/atom.xml</id>
  <updated>2023-05-20T15:50:35Z</updated>
  <link href="tanzhijian.org"/>
  <link href="https://tanzhijian.org/atom.xml" rel="self"/>
  <generator>?</generator>
  <entry>
    <title>阿森纳不败赛季射门探索 02: xG 特征</title>
    <link href="https://tanzhijian.org/posts/invincible_06"></link>
    <id>1684569035.9120426</id>
    <updated>2023-05-20T15:50:35Z</updated>
    <published>2023-05-20T15:50:35Z</published>
    <author><name>tanzhijian</name></author>
    <summary>b 站刷到了一个 StatsBomb 的 xG 教学视频 [https://www.bilibili.com/video/BV13V4y1k77j](https://www.bilibili.com/video/BV13V4y1k77j), 更详细介绍了他们使用的 xG 特征，其视频后段也列了出来，重要的特征还标注了星标：
</summary>
    <content type="html">
      <h1>阿森纳不败赛季射门探索 02: xG 特征</h1>
<p>b 站刷到了一个 StatsBomb 的 xG 教学视频 <a href="https://www.bilibili.com/video/BV13V4y1k77j">https://www.bilibili.com/video/BV13V4y1k77j</a>, 更详细介绍了他们使用的 xG 特征，其视频后段也列了出来，重要的特征还标注了星标：</p>
<ul>
<li><strong>射门距离</strong></li>
<li><strong>射门角度</strong></li>
<li>射门身体部位</li>
<li><strong>射门是否来自定位球</strong></li>
<li><strong>射门是否来自传中，什么类型的传中</strong></li>
<li>射门是否来自直塞球</li>
<li>射门是否来自完成盘带后</li>
<li><strong>射门时接近的防守队员</strong></li>
<li>防守区域或者密度</li>
<li><strong>射门与球门形成的三角形内球员人数</strong></li>
<li>守门员的位置</li>
<li>射门时球的高度</li>
</ul>
<p>比起上一篇文章从他们的推特视频推断出的特征，多了一些射门前动作的判定。定位球需要单独的模型训练这个自不消说；射门前的动作，通过推进调整后的射门，球在脚下理论上射门难度是最低的；接到直塞球和完成盘带后球可能不会处在一个很舒服的位置；接到传中的射门最难，且球的高度越高越难以把握。</p>
<p>由于写这篇文章是在外地，身边的设备只有一台 iPad，不能获取到数据进行特征提取，也不能写代码，所以接下来的特征提取用探讨的方式，下次再补充代码。</p>
<p>首先是射门前的事件，在获取射门事件时通过 <code>id - 1</code> 可以得到。</p>
<p>查看之前写的文章 <a href="https://tanzhijian.org/posts/invincible01">不败赛季传球路线图探索 01</a> 在 type_name 里有 'Dribbled Past', 'Dribble' ，可以获取到特征，射门是否来自完成盘带后。</p>
<p>直塞和传中，在 columns 里有 pass_cross，但没有直塞球 through，如果不能通过已有特征判定，则只能假设计算：传球与射门坐标连接的线，与射门的 y 轴形成的夹角小于 45 度，且最后射门类型为脚，则可以判定成直塞球，其余的均为传中，如下草图所示：</p>
<p><img src="https://s2.loli.net/2023/05/20/4qnLOPTJ6jad5gB.png" alt="through_ball.png" /></p>
<p>传中类型也通过最后的射门判定，用脚是低球传中，头球或其他则是高球传中。</p>
<p>射门部位在 StatsBomb 的公开数据里并没有球员的相关数据，不然可以通过判定射门时用脚和球员惯用脚是否为逆足，来获得更加准确的特征。</p>
<p>而防守区域或者密度，在视频里解释为不仅仅是防守者，还有进攻者——他的队友在哪里，都是潜在的阻挡射门的球员。虽然我并不认同这是个有用的特征，但还是把它加进来。采取的方式为射门位置 x 轴之后的球员均为防守区域的人数。</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季射门探索 01: xG</title>
    <link href="https://tanzhijian.org/posts/invincible_05"></link>
    <id>1684157980.5444288</id>
    <updated>2023-05-15T21:39:40Z</updated>
    <published>2023-05-15T21:39:40Z</published>
    <author><name>tanzhijian</name></author>
    <summary>从 xG 开始。训练一个 xG 的模型方便之后的探索使用
</summary>
    <content type="html">
      <h1>阿森纳不败赛季射门探索 01: xG</h1>
<p>从 xG 开始。训练一个 xG 的模型方便之后的探索使用</p>
<h2>预处理数据</h2>
<p>由于数据同样出自 Statsbomb，所以数据集使用他们的 opendata，获取 competitions 一共有 43 个赛季的不同性质比赛可以使用，但由于比赛差异，需要去除女子足球的比赛，然后去除阿森纳不败赛季的比赛作为测试集，过滤以后还有 36 个赛季 828 场的比赛可以使用</p>
<p>接下来获取所有的比赛事件，以及随之的跟踪数据事件，有一些需要注意的处理方法:</p>
<pre><code class="language-python"># 使用 mplsoccer 获取数据，每场比赛事件分别是 events, related, freeze, tactics
events = match[0]
tracks = match[2]

# 获取射门事件
# 把 Statsbomb 的坐标从 120 80 转换为 105 68 是方便之后绘图使用
shots = events.loc[events[&quot;type_name&quot;] == &quot;Shot&quot;].copy()
x_formula = lambda x: x * 105 / 120
y_formula = lambda x: x * 68 / 80
shots.x = shots.x.apply(x_formula)
shots.y = shots.y.apply(y_formula)
tracks.x = tracks.x.apply(x_formula)
tracks.y = tracks.y.apply(y_formula)
</code></pre>
<p>然后过滤掉定位球射门，以及未跟踪守门员的射门以后，还剩下 19174 条射门事件，数据不算大，但可以训练模型了</p>
<h2>特征提取</h2>
<p>如何选择特征呢，既然使用 Statsbomb 的数据，不妨找找他在这方面的资料，于是找到了 Statsbomb 发布的这条推特 <a href="https://twitter.com/StatsBomb/status/1650847925197471745">https://twitter.com/StatsBomb/status/1650847925197471745</a>已经有了答案：</p>
<blockquote>
<p>Not all xG is created equal.</p>
<p>StatsBomb's xG model includes:</p>
<ul>
<li>the positioning of the goalkeeper</li>
<li>the positioning of the surrounding defenders and attackers</li>
<li>the height of the ball at the moment the shot is struck</li>
</ul>
</blockquote>
<p>结合推特里面的视频，总结出 Statsbomb 的 xG 主要使用以下特征：</p>
<ul>
<li>射门距离</li>
<li>射门角度</li>
<li>基础 xg</li>
<li>守门员的位置</li>
<li>守门员与射门的距离</li>
<li>射门是否比守门员更接近球门</li>
<li>干扰射门的防守球员</li>
<li>射门与球门形成的三角形内防守球员</li>
<li>射门与球门形成的三角形内进攻球员</li>
<li>射门时球的高度</li>
</ul>
<p>其中干扰射门的防守球员是一个不好把握的特征，在这里假设射门时球半径 1 米内的防守球员都属于干扰射门</p>
<p>而射门时球的高度在没有具体的数据情况下是个更难的特征，大致原理为球的高度越高，xG 越低，脚射门比较准，而头球在同样距离的情况下更难把握住。Statsbomb 射门事件关于这一项特征 body_part_name 其中只包含了['Right Foot', 'Head', 'Left Foot', 'Other']，所以仍然需要假设。询问 chatgpt，男子足球运动员平均身高为 1.8 米（感觉偏高？），所以假设头球的高度统一为 1.8，脚下射门为 0.01, 其他可以理解为胸口，大腿等非常规部位，为 1.0</p>
<p>由于特征提取是一项不小的工程，所以在 GitHub 创建了一个库 <a href="https://github.com/tanzhijian/football-calculator">https://github.com/tanzhijian/football-calculator</a> ，如果查看时代码已经修改了，可以回滚到这篇文章写的日期，也就是 2023-05-14</p>
<h2>训练模型</h2>
<p>特征提取完毕以后可以得到一个 (19174, 10) 型状的数据集，开始创建一个神经网络进行训练，由于我并不擅长机器学习，所以随便写了一个先训练着，训练数据集和验证数据集 8:2，然后创建模型：</p>
<pre><code class="language-python">model = tf.keras.Sequential([
    layers.Dense(10, activation=&quot;relu&quot;, input_shape=(10,)),
    layers.Dense(10, activation=&quot;relu&quot;),
    layers.Dense(1, activation=&quot;sigmoid&quot;)
])
model.compile(
    optimizer=&#x27;adam&#x27;,
    loss=&quot;binary_crossentropy&quot;, 
    metrics=[&quot;accuracy&quot;]
)
history = model.fit(
    X_train, 
    y_train, 
    validation_data=(X_val, y_val),
    batch_size=32, 
    epochs=50,
)
</code></pre>
<p>测试数据库使用不败赛季的 832 个射门事件</p>
<pre><code class="language-python"># 计算精确度，召回率和 f1 分数
report = classification_report(y_test, y_pred)
print(report)
</code></pre>
<pre><code>              precision    recall  f1-score   support

           0       0.92      1.00      0.95       754
           1       0.75      0.12      0.20        78

    accuracy                           0.91       832
   macro avg       0.83      0.56      0.58       832
weighted avg       0.90      0.91      0.88       832
</code></pre>
<p>分数有点惨，但考虑到数据库大小，推断出的特征，一些乱七八糟的假设，随便设置的神经网络，能有这样也还不错了</p>
<p>接下来计算 xG 并查看</p>
<pre><code class="language-python">invincible_shots.groupby([&quot;player_name&quot;])[&quot;xg&quot;].sum().sort_values(
    ascending=False
)[:5].reset_index()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Thierry Henry</td>
      <td>15.798578</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Robert Pirès</td>
      <td>6.998034</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Fredrik Ljungberg</td>
      <td>4.917759</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dennis Bergkamp</td>
      <td>4.257910</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Kolo Habib Touré</td>
      <td>3.186363</td>
    </tr>
  </tbody>
</table>
</div>
<p>Statsbomb 数据里面有自带计算完毕的 xG 可以作为标准</p>
<pre><code class="language-python">invincible_shots.groupby([&quot;player_name&quot;])[&quot;shot_statsbomb_xg&quot;].sum().sort_values(
    ascending=False
)[:5].reset_index()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>shot_statsbomb_xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Thierry Henry</td>
      <td>17.330713</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Robert Pirès</td>
      <td>6.959468</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Fredrik Ljungberg</td>
      <td>5.271573</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dennis Bergkamp</td>
      <td>4.135871</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Patrick Vieira</td>
      <td>3.469172</td>
    </tr>
  </tbody>
</table>
</div>
<p>还是有差异，考虑到上面提到的因素，可以接受</p>
<p>查看一些个别的</p>
<pre><code class="language-python">invincible_shots[[&quot;player_name&quot;, &quot;xg&quot;, &quot;shot_statsbomb_xg&quot;]].head(10)
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>xg</th>
      <th>shot_statsbomb_xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Dennis Bergkamp</td>
      <td>0.153065</td>
      <td>0.193885</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Thierry Henry</td>
      <td>0.032303</td>
      <td>0.007914</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Gilberto Aparecido da Silva</td>
      <td>0.102811</td>
      <td>0.125604</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Paul Butler</td>
      <td>0.085732</td>
      <td>0.065221</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>0.044693</td>
      <td>0.043912</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Ioan Viorel Ganea</td>
      <td>0.070132</td>
      <td>0.085242</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Dennis Bergkamp</td>
      <td>0.021920</td>
      <td>0.018803</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Carl Cort</td>
      <td>0.062670</td>
      <td>0.051536</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Ioan Viorel Ganea</td>
      <td>0.229663</td>
      <td>0.256359</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Kenny Miller</td>
      <td>0.044943</td>
      <td>0.027489</td>
    </tr>
  </tbody>
</table>
</div>
<p>暂时可以用，之后时间再来优化了</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 04</title>
    <link href="https://tanzhijian.org/posts/invincible_04"></link>
    <id>1682751927.7004185</id>
    <updated>2023-04-29T15:05:27Z</updated>
    <published>2023-04-29T15:05:27Z</published>
    <author><name>tanzhijian</name></author>
    <summary>这一次探索单个球员的进攻传球路线。首先还是画出热区图，准备数据的部分和前面一篇相同，就不重复写了，直接跳到 danger_passes
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 04</h1>
<p>这一次探索单个球员的进攻传球路线。首先还是画出热区图，准备数据的部分和前面一篇相同，就不重复写了，直接跳到 danger_passes</p>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen, VerticalPitch
</code></pre>
<pre><code class="language-python">danger_passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>minute</th>
      <th>second</th>
      <th>player_name</th>
      <th>player_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>52.6</td>
      <td>54.3</td>
      <td>54.6</td>
      <td>45.0</td>
      <td>8</td>
      <td>4</td>
      <td>Patrick Vieira</td>
      <td>15515.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>69.9</td>
      <td>28.5</td>
      <td>102.0</td>
      <td>26.9</td>
      <td>8</td>
      <td>8</td>
      <td>Eduardo César Daude Gaspar</td>
      <td>26014.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>102.0</td>
      <td>26.9</td>
      <td>104.7</td>
      <td>37.6</td>
      <td>8</td>
      <td>10</td>
      <td>Ashley Cole</td>
      <td>12529.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>60.0</td>
      <td>45.6</td>
      <td>68.9</td>
      <td>33.9</td>
      <td>12</td>
      <td>7</td>
      <td>Robert Pirès</td>
      <td>19312.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>68.5</td>
      <td>33.9</td>
      <td>79.1</td>
      <td>31.1</td>
      <td>12</td>
      <td>9</td>
      <td>Eduardo César Daude Gaspar</td>
      <td>26014.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>探索单个球员</h2>
<p>作为威胁传球的核心，首先来探索皮雷，手动在名单里获取皮雷的 id，然后过滤</p>
<pre><code class="language-python">bins = (6, 5)
</code></pre>
<pre><code class="language-python">pires = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 19312]
</code></pre>
<pre><code class="language-python">def plot_player_passes(player, passes):
    pitch = Pitch(line_zorder=2, line_color=&quot;grey&quot;)
    fig, ax = pitch.grid(
        grid_height=0.9,
        title_height=0.06,
        axis=False,
        endnote_height=0.04,
        title_space=0,
        endnote_space=0,
    )

    bin_statistic = pitch.bin_statistic(
        player.x,
        player.y,
        statistic=&quot;count&quot;,
        bins=bins,
        normalize=False,
    )

    # 制作热区图
    pcm = pitch.heatmap(
        bin_statistic, 
        cmap=&quot;Reds&quot;, 
        # edgecolor=&quot;grey&quot;, 
        ax=ax[&quot;pitch&quot;],
    )

    # 绘制传球路线
    pitch.arrows(
        passes.x,
        passes.y,
        passes.end_x,
        passes.end_y,
        color=&quot;black&quot;,
        alpha=1,
        width=2,
        ax=ax[&quot;pitch&quot;],
    )

    fig.suptitle(f&quot;{player.iloc[0].player_name}&quot;, fontsize=30)
    plt.show()
</code></pre>
<pre><code class="language-python">plot_player_passes(pires, pires)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/6ujT13XKcx7EnOg.png" alt="attacking_play_pires_01.png" /></p>
<p>这样的路线看起来未免杂乱，这里使用 Opta 的一种传球表现图：球场分成 10 * 10 的区域，每一块区域传球次数越多颜色越深，箭头表示此区域的平均传球方向</p>
<pre><code class="language-python">bins = (10, 10)
</code></pre>
<pre><code class="language-python">def binning_groupby_mean(player):
    x_bins = [i for i in range(0, 121, 120 // bins[0])]
    y_bins = [i for i in range(0, 81, 80 // bins[1])]
    player[&#x27;x_bin&#x27;] = pd.cut(player[&#x27;x&#x27;], x_bins)
    player[&#x27;y_bin&#x27;] = pd.cut(player[&#x27;y&#x27;], y_bins)
    return player.groupby([&#x27;x_bin&#x27;, &#x27;y_bin&#x27;]).mean()
</code></pre>
<pre><code class="language-python">mean_passes = binning_groupby_mean(pires)
plot_player_passes(pires, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/OtbKrZBPfMTLyaF.png" alt="attacking_play_pires_02.png" /></p>
<p>边路进攻核心活动区域，次数最多的是左路肋部区域，在较少拿球的区域传球的距离比较长，到了不是自己的位置会将球传到熟悉的区域而不是就地组织，很少有长距离传中路线</p>
<pre><code class="language-python">vieira = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15515]
mean_passes = binning_groupby_mean(vieira)
plot_player_passes(vieira, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/DmBf7sAeSutwWM1.png" alt="attacking_play_vieira.png" /></p>
<p>覆盖了整个中场，核心传球区域与皮雷很近，传球选择路线更偏向左路</p>
<pre><code class="language-python">henry = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15516]
mean_passes = binning_groupby_mean(henry)
plot_player_passes(henry, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/dv3SfFq8Z4QpCXb.png" alt="attacking_play_henry.png" /></p>
<p>与印象不同的是，在中路禁区前沿有着大量的传球，且都是向前的路线，往禁区送出了大量的威胁球，所以在进球同时会收获那么多的助攻</p>
<pre><code class="language-python">player = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15042]
mean_passes = binning_groupby_mean(player)
plot_player_passes(player, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/tPTJrEHj97U5pd1.png" alt="attacking_play_bergkamp.png" /></p>
<p>活动位置更像是进攻型中场，传球也大多找的禁区前的队友</p>
<pre><code class="language-python">player = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15754]
mean_passes = binning_groupby_mean(player)
plot_player_passes(player, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/GVHYfwemKSIEyX2.png" alt="attacking_play_ljungberg.png" /></p>
<p>与皮雷不一样的是，就地选择进攻传球更为频繁，习惯性活动范围固定在几块，可能与他场上位置更多变有关</p>
<p>传球路线图就到这里了，下一次探索些别的</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 03</title>
    <link href="https://tanzhijian.org/posts/invincible_03"></link>
    <id>1681920025.721563</id>
    <updated>2023-04-20T00:00:25Z</updated>
    <published>2023-04-20T00:00:25Z</published>
    <author><name>tanzhijian</name></author>
    <summary>这次用热区图的形式来探索，与平时所看的全场比赛事件分布热区图不一样的是，用的是危险传球——这次把射门前 15 秒内的传球都视为危险传球。
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 03</h1>
<p>这次用热区图的形式来探索，与平时所看的全场比赛事件分布热区图不一样的是，用的是危险传球——这次把射门前 15 秒内的传球都视为危险传球。</p>
<p>前面获取数据部分和上一篇大致相同</p>
<h2>import</h2>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen, VerticalPitch
</code></pre>
<pre><code class="language-python">parser = Sbopen()
matches = parser.match(competition_id=2, season_id=44)
matches_events = []
for match_id in matches[&#x27;match_id&#x27;]:
    data = parser.event(match_id)
    matches_events.append(data[0])
</code></pre>
<h2>获取危险传球</h2>
<p>获取阿森纳所有比赛的射门和准确传球，且传球不是定位球，然后寻找射门前 15 秒的传球，对于时间需要考虑上下半场，伤停补时的特殊处理</p>
<pre><code class="language-python">danger_passes = pd.DataFrame()
for events in matches_events:
    # 上下半场
    for period in [1, 2]:
        # 只保留没有定位球的准确传球
        pass_filter = (
            events.team_name == &#x27;Arsenal&#x27;) &amp; (
            events.type_name == &quot;Pass&quot;) &amp; (
            events.outcome_name.isnull()) &amp; (
            events.period == period) &amp; (
            events.sub_type_name.isnull())
        passes = events.loc[
            pass_filter, 
            [
                &quot;x&quot;, &quot;y&quot;, &quot;end_x&quot;, &quot;end_y&quot;, 
                &quot;minute&quot;, &quot;second&quot;, &quot;player_name&quot;,
            ],
        ]
        # 只保留阿森纳的射门
        shot_filter = (
            events.team_name == &#x27;Arsenal&#x27;) &amp; (
            events.type_name == &quot;Shot&quot;) &amp; (
            events.period == period)
        shots = events.loc[shot_filter, [&quot;minute&quot;, &quot;second&quot;]]
        shot_times = shots[&#x27;minute&#x27;] * 60 + shots[&#x27;second&#x27;]
        
        # 设置为射门前 15 秒
        shot_anchor = 15
        shot_start = shot_times - shot_anchor
        
        # 处理时间
        shot_start = shot_start.apply(lambda i: i if i &gt; 0 else (period - 1) * 45)
        pass_times = passes[&#x27;minute&#x27;] * 60 + passes[&#x27;second&#x27;]

        pass_to_shot = pass_times.apply(
            lambda x: True in ((shot_start &lt; x) &amp; (x &lt; shot_times)).unique())

        # 只保留危险传球
        danger_passes_period = passes.loc[pass_to_shot]
        danger_passes = pd.concat(
            [danger_passes, danger_passes_period], 
            ignore_index=True
        )
</code></pre>
<pre><code class="language-python">danger_passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>minute</th>
      <th>second</th>
      <th>player_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>52.6</td>
      <td>54.3</td>
      <td>54.6</td>
      <td>45.0</td>
      <td>8</td>
      <td>4</td>
      <td>Patrick Vieira</td>
    </tr>
    <tr>
      <th>1</th>
      <td>69.9</td>
      <td>28.5</td>
      <td>102.0</td>
      <td>26.9</td>
      <td>8</td>
      <td>8</td>
      <td>Eduardo César Daude Gaspar</td>
    </tr>
    <tr>
      <th>2</th>
      <td>102.0</td>
      <td>26.9</td>
      <td>104.7</td>
      <td>37.6</td>
      <td>8</td>
      <td>10</td>
      <td>Ashley Cole</td>
    </tr>
    <tr>
      <th>3</th>
      <td>60.0</td>
      <td>45.6</td>
      <td>68.9</td>
      <td>33.9</td>
      <td>12</td>
      <td>7</td>
      <td>Robert Pirès</td>
    </tr>
    <tr>
      <th>4</th>
      <td>68.5</td>
      <td>33.9</td>
      <td>79.1</td>
      <td>31.1</td>
      <td>12</td>
      <td>9</td>
      <td>Eduardo César Daude Gaspar</td>
    </tr>
  </tbody>
</table>
</div>
<h2>绘制热区图</h2>
<p>这次在球场上使用 6 * 5 的格子来制作，其中宽度区域对应中肋边路，六块长度区域在瓜迪奥拉的战术板经常能看到</p>
<pre><code class="language-python">pitch = Pitch(line_zorder=2, line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0
)

bin_statistic = pitch.bin_statistic(
    danger_passes.x, danger_passes.y, 
    statistic=&#x27;count&#x27;, bins=(6, 5), normalize=False,
)

# 绘制热区图
pcm = pitch.heatmap(
    bin_statistic, cmap=&#x27;Reds&#x27;, edgecolor=&#x27;black&#x27;, ax=ax[&#x27;pitch&#x27;]
)

# 绘制说明
ax_cbar = fig.add_axes((1, 0.093, 0.03, 0.786))
cbar = plt.colorbar(pcm, cax=ax_cbar)

fig.suptitle(&#x27;Danger passes by Arsenal&#x27;, fontsize=30)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/19/9yWTgXGkQbl2vKf.png" alt="arsenal_0304_danger_pass_heatmap.png" /></p>
<h2>绘制参与危险传球最多球员的图表</h2>
<p>为了更加清晰的探索，将球员参与的传球次数绘制出来</p>
<p>这次偷个懒就不与 nickname 结合了</p>
<pre><code class="language-python">passes_count = danger_passes.groupby([&#x27;player_name&#x27;]).x.count()

ax = passes_count.plot.barh(passes_count)
ax.set_xlabel(&#x27;Number of danger passes&#x27;)
ax.set_ylabel(&#x27;&#x27;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/19/IO2bqtkSLTKjhCg.png" alt="number_of_arsenal_0304_danger_pass.png" /></p>
<h2>结论</h2>
<ol>
<li>维埃拉-皮雷-亨利占据了形成射门的大多数传球，球会经过他们很多次，是整个进攻体系的核心</li>
<li>博格坎普受限于出场(21次首发8次替补)，他的进攻参与度重要性不亚于 1</li>
<li>亨利作为终结者，在进攻传球网络中也有如此重要的数据，全能</li>
<li>左路肋部区域承担了推进至禁区的大多任务，</li>
<li>右路参与的控球大多数会通过中路交到左路，少部分会在右路传到禁区</li>
</ol>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 02</title>
    <link href="https://tanzhijian.org/posts/invincible_02"></link>
    <id>1681501683.1309137</id>
    <updated>2023-04-15T03:48:03Z</updated>
    <published>2023-04-15T03:48:03Z</published>
    <author><name>tanzhijian</name></author>
    <summary>上篇文章选取了其中一场的比赛，其主力阵容除了右边前卫帕洛尔，其余都是不败赛季夺冠的常规主力，这次的探索目标为整个赛季的所有比赛，作为常规主力的十一人传球路线图
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 02</h1>
<p>上篇文章选取了其中一场的比赛，其主力阵容除了右边前卫帕洛尔，其余都是不败赛季夺冠的常规主力，这次的探索目标为整个赛季的所有比赛，作为常规主力的十一人传球路线图</p>
<p>首先是获取 38 场比赛的数据集</p>
<h2>import</h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen
</code></pre>
<pre><code class="language-python"># 获取所有比赛的 id
parser = Sbopen()
matches = parser.match(competition_id=2, season_id=44)
</code></pre>
<pre><code class="language-python"># 获取所有比赛的事件数据集
events = []
for match_id in matches[&#x27;match_id&#x27;]:
    data = parser.event(match_id)
    # data[0] 为 event
    events.append(data[0])
</code></pre>
<h2>获取需要的数据</h2>
<p>现在需要找到首发 11 人的 player_id, 这一步手动来完成了，也就是上一篇文章的首发阵容 id，然后把帕洛尔换成永贝里</p>
<pre><code class="language-python">invincible_11 = [
    20015,
    40222, 38412, 15637, 12529,
    15754, 40221, 15515, 19312,
    15042, 15516,
]
</code></pre>
<pre><code class="language-python"># 手动获取一场全部 11 人阵容的比赛
lineup = parser.lineup(3749257)
invincible_11 = pd.merge(
    pd.DataFrame({&#x27;player_id&#x27;: invincible_11}),
    lineup[[&#x27;player_id&#x27;, &#x27;player_nickname&#x27;,]],
    on=&#x27;player_id&#x27;
)
</code></pre>
<p>接下来设置过滤条件，和上一篇文章差不多：</p>
<ol>
<li>对手的事件</li>
<li>失败的传球</li>
<li>传球队员与接球队员是否 invincible_11</li>
</ol>
<pre><code class="language-python">def mask(events):
    _filter = (
    events.type_name == &#x27;Pass&#x27;) &amp; (
    events.team_name == &quot;Arsenal&quot;) &amp; (
    events.player_id.isin(invincible_11.player_id)) &amp; (
    events.pass_recipient_id.isin(invincible_11.player_id)) &amp; (
    events.outcome_name.isnull())
    
    passes = events.loc[_filter, [
        &#x27;x&#x27;, &#x27;y&#x27;, &#x27;end_x&#x27;, &#x27;end_y&#x27;,
        &#x27;player_id&#x27;, &#x27;player_name&#x27;, &#x27;pass_recipient_name&#x27;, &#x27;pass_recipient_id&#x27;
    ]]
    return passes
</code></pre>
<pre><code class="language-python">passes = pd.concat([mask(event) for event in events])
</code></pre>
<pre><code class="language-python">passes = passes.reset_index()
passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>index</th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>player_id</th>
      <th>player_name</th>
      <th>pass_recipient_name</th>
      <th>pass_recipient_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>61.0</td>
      <td>40.1</td>
      <td>61.4</td>
      <td>43.6</td>
      <td>15516.0</td>
      <td>Thierry Henry</td>
      <td>Dennis Bergkamp</td>
      <td>15042.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>12</td>
      <td>37.6</td>
      <td>2.9</td>
      <td>23.4</td>
      <td>24.7</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>11.1</td>
      <td>9.7</td>
      <td>7.7</td>
      <td>21.5</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>75</td>
      <td>17.7</td>
      <td>11.5</td>
      <td>26.2</td>
      <td>8.1</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Robert Pirès</td>
      <td>19312.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>97</td>
      <td>25.3</td>
      <td>29.3</td>
      <td>30.0</td>
      <td>49.1</td>
      <td>38412.0</td>
      <td>Kolo Habib Touré</td>
      <td>Laureano Bisan-Etame Mayer</td>
      <td>40222.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>画图</h2>
<pre><code class="language-python"># 计算位置和大小
scatter = pd.DataFrame()
for i, _id in enumerate(passes[&#x27;player_id&#x27;].unique()):
    pass_x = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;x&#x27;].to_numpy()
    pass_y = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;y&#x27;].to_numpy()
    rec_x = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_x&#x27;].to_numpy()
    rec_y = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_y&#x27;].to_numpy()
    scatter.at[i, &#x27;player_id&#x27;] = _id
    
    # 计算每个点的 x 和 y，位置为传球和接球的平均值
    scatter.at[i, &#x27;x&#x27;] = np.mean(np.concatenate([pass_x, rec_x]))
    scatter.at[i, &#x27;y&#x27;] = np.mean(np.concatenate([pass_y, rec_y]))
    
    # 计算传球数
    scatter.at[i, &#x27;count&#x27;] = passes.loc[
        passes[&#x27;player_id&#x27;] == _id].count().iloc[0]
</code></pre>
<pre><code class="language-python"># 位置大小
scatter[&#x27;marker_size&#x27;] = scatter[&#x27;count&#x27;] / scatter[&#x27;count&#x27;].max() * 3000
</code></pre>
<pre><code class="language-python"># 合并名字
scatter = pd.merge(
    scatter,
    invincible_11,
    on=&#x27;player_id&#x27;
)
</code></pre>
<pre><code class="language-python"># 计算球员之间的传球次数
passes[&#x27;pair_key&#x27;] = passes.apply(
    lambda x: &#x27;-&#x27;.join(sorted([str(x[&#x27;player_id&#x27;]), 
                               str(x[&#x27;pass_recipient_id&#x27;])])),
    axis=1,
)
lines = passes.groupby([&#x27;pair_key&#x27;]).x.count().reset_index()
lines.rename({&#x27;x&#x27;: &#x27;pass_count&#x27;}, axis=&#x27;columns&#x27;, inplace=True)

# 设定一个阈值，可以尝试研究它在更改时如何变化
lines = lines[lines[&#x27;pass_count&#x27;] &gt; 4 * 38]

# 绘制球场
pitch = Pitch(line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0,
)
# 球场上的位置
pitch.scatter(
    scatter.x, scatter.y, s=scatter.marker_size, 
    color=&#x27;red&#x27;, edgecolors=&#x27;grey&#x27;, linewidth=1, alpha=0.8,
    ax=ax[&#x27;pitch&#x27;], zorder=3,
)

# 填充球员名字
for i, row in scatter.iterrows():
    pitch.annotate(
        row.player_nickname, xy=(row.x, row.y), c=&#x27;black&#x27;, 
        va=&#x27;center&#x27;, ha=&#x27;center&#x27;, weight=&quot;bold&quot;, 
        size=14, ax=ax[&quot;pitch&quot;], zorder=4,
    )
    
for i, row in lines.iterrows():
    player1 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[0])
    player2 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[1])
    
    # 取球员的平均位置在他们之间画一条线
    player1_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;x&#x27;].iloc[0]
    player1_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;y&#x27;].iloc[0]
    player2_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;x&#x27;].iloc[0]
    player2_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;y&#x27;].iloc[0]
    passes_count = row[&#x27;pass_count&#x27;]
    # 调整线宽，传球的次数越多，线越宽
    line_width = passes_count / lines[&#x27;pass_count&#x27;].max() * 15

    pitch.lines(
        player1_x, player1_y, player2_x, player2_y,
        alpha=0.8, lw=line_width, zorder=2, color=&#x27;red&#x27;, ax=ax[&#x27;pitch&#x27;]
    )
    
fig.suptitle(&#x27;Invincible 11&#x27;, fontsize=30)
plt.show()

</code></pre>
<p><img src="https://s2.loli.net/2023/04/15/LN5KPG6efpjFRMC.png" alt="invincible_11_passing_networks.png" /></p>
<h2>结论</h2>
<p>高中时期我和好友无数次在实况足球里面模拟这一套 442，现在看到还原出来蛮感慨</p>
<ol>
<li>莱曼的出球线路，图雷，较少直接找两个边后卫，很少开大脚</li>
<li>图雷担任出球中卫</li>
<li>劳伦这一侧的球权比想象中多</li>
<li>吉尔伯托在后场出球系统中几乎和维埃拉同样重要，但他没有向前传球的路线</li>
<li>托后三人组，坎贝尔，图雷，吉尔伯托</li>
<li>阿什利科尔 - 皮雷 - 亨利是主要的推进线路</li>
<li>永贝里的主要进攻路线是传中找亨利</li>
<li>皮雷当之无愧的进攻核心</li>
<li>所有的进攻球都在找亨利</li>
<li>博格坎普可能受制于出场时间，并没有想象中重要</li>
</ol>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 01</title>
    <link href="https://tanzhijian.org/posts/invincible01"></link>
    <id>1681234440.864004</id>
    <updated>2023-04-12T01:34:00Z</updated>
    <published>2023-04-12T01:34:00Z</published>
    <author><name>tanzhijian</name></author>
    <summary>statsbomb 有一些有趣的公开数据，比如梅西的职业生涯，阿森纳的不败赛季，最近在上足球数据可视化的课程，刚好拿来玩一玩。
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 01</h1>
<p>statsbomb 有一些有趣的公开数据，比如梅西的职业生涯，阿森纳的不败赛季，最近在上足球数据可视化的课程，刚好拿来玩一玩。</p>
<p>通过 competitions 找到英超联赛 0304赛季的 id，其中只有阿森纳的比赛，这次随便获取一场比赛来试手，2004 年 4 月 25 日北伦敦德比，阿森纳在白鹿巷球场 2:2 战平热刺，高举起英格兰超级联赛冠军奖杯，就它了。</p>
<h2>import</h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen

match_id = 3749068
</code></pre>
<pre><code class="language-python">parser = Sbopen()
events, related, freeze, tactics = parser.event(match_id)
</code></pre>
<pre><code class="language-python"># 检查一下数据集
events.info()
</code></pre>
<pre><code>&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;
RangeIndex: 3156 entries, 0 to 3155
Data columns (total 77 columns):
 #   Column                          Non-Null Count  Dtype  
---  ------                          --------------  -----  
 0   id                              3156 non-null   object 
 1   index                           3156 non-null   int64  
 2   period                          3156 non-null   int64  
 3   timestamp                       3156 non-null   object 
 4   minute                          3156 non-null   int64  
 5   second                          3156 non-null   int64  
 6   possession                      3156 non-null   int64  
 7   duration                        2355 non-null   float64
 8   match_id                        3156 non-null   int64  
 9   type_id                         3156 non-null   int64  
 10  type_name                       3156 non-null   object 
 11  possession_team_id              3156 non-null   int64  
 12  possession_team_name            3156 non-null   object 
 13  play_pattern_id                 3156 non-null   int64  
 14  play_pattern_name               3156 non-null   object 
 15  team_id                         3156 non-null   int64  
 16  team_name                       3156 non-null   object 
 17  tactics_formation               3 non-null      float64
 18  player_id                       3145 non-null   float64
 19  player_name                     3145 non-null   object 
 20  position_id                     3145 non-null   float64
 21  position_name                   3145 non-null   object 
 22  pass_recipient_id               801 non-null    float64
 23  pass_recipient_name             801 non-null    object 
 24  pass_length                     879 non-null    float64
 25  pass_angle                      879 non-null    float64
 26  pass_height_id                  879 non-null    float64
 27  pass_height_name                879 non-null    object 
 28  end_x                           1571 non-null   float64
 29  end_y                           1571 non-null   float64
 30  body_part_id                    899 non-null    float64
 31  body_part_name                  899 non-null    object 
 32  sub_type_id                     322 non-null    float64
 33  sub_type_name                   322 non-null    object 
 34  x                               3139 non-null   float64
 35  y                               3139 non-null   float64
 36  outcome_id                      434 non-null    float64
 37  outcome_name                    434 non-null    object 
 38  under_pressure                  670 non-null    float64
 39  counterpress                    82 non-null     float64
 40  off_camera                      65 non-null     float64
 41  aerial_won                      38 non-null     object 
 42  out                             34 non-null     float64
 43  ball_recovery_recovery_failure  11 non-null     object 
 44  pass_switch                     38 non-null     object 
 45  foul_committed_advantage        5 non-null      object 
 46  foul_won_advantage              5 non-null      object 
 47  technique_id                    50 non-null     float64
 48  technique_name                  50 non-null     object 
 49  pass_assisted_shot_id           16 non-null     object 
 50  pass_goal_assist                3 non-null      object 
 51  shot_open_goal                  1 non-null      object 
 52  shot_statsbomb_xg               23 non-null     float64
 53  end_z                           19 non-null     float64
 54  shot_key_pass_id                16 non-null     object 
 55  shot_first_time                 8 non-null      object 
 56  goalkeeper_position_id          23 non-null     float64
 57  goalkeeper_position_name        23 non-null     object 
 58  pass_cross                      15 non-null     object 
 59  dribble_overrun                 3 non-null      object 
 60  ball_recovery_offensive         2 non-null      object 
 61  pass_shot_assist                13 non-null     object 
 62  foul_won_defensive              9 non-null      object 
 63  pass_deflected                  2 non-null      object 
 64  half_start_late_video_start     2 non-null      object 
 65  substitution_replacement_id     5 non-null      float64
 66  substitution_replacement_name   5 non-null      object 
 67  foul_committed_card_id          2 non-null      float64
 68  foul_committed_card_name        2 non-null      object 
 69  dribble_nutmeg                  1 non-null      object 
 70  shot_one_on_one                 1 non-null      object 
 71  pass_cut_back                   1 non-null      object 
 72  block_offensive                 1 non-null      object 
 73  foul_committed_penalty          1 non-null      object 
 74  foul_won_penalty                1 non-null      object 
 75  bad_behaviour_card_id           1 non-null      float64
 76  bad_behaviour_card_name         1 non-null      object 
dtypes: float64(26), int64(10), object(41)
memory usage: 1.9+ MB
</code></pre>
<pre><code class="language-python"># 查看有哪些事件
events[&#x27;type_name&#x27;].unique()
</code></pre>
<pre><code>array([&#x27;Starting XI&#x27;, &#x27;Half Start&#x27;, &#x27;Pass&#x27;, &#x27;Ball Receipt&#x27;, &#x27;Carry&#x27;,
       &#x27;Block&#x27;, &#x27;Ball Recovery&#x27;, &#x27;Pressure&#x27;, &#x27;Duel&#x27;, &#x27;Clearance&#x27;,
       &#x27;Foul Committed&#x27;, &#x27;Foul Won&#x27;, &#x27;Dribbled Past&#x27;, &#x27;Dribble&#x27;, &#x27;Shot&#x27;,
       &#x27;Goal Keeper&#x27;, &#x27;Dispossessed&#x27;, &#x27;Interception&#x27;, &#x27;Miscontrol&#x27;,
       &#x27;50/50&#x27;, &#x27;Offside&#x27;, &#x27;Half End&#x27;, &#x27;Substitution&#x27;, &#x27;Error&#x27;,
       &#x27;Tactical Shift&#x27;, &#x27;Bad Behaviour&#x27;], dtype=object)
</code></pre>
<p>由于换人了以后阵容战术就会变动，所以绘制首发传球图需要在第一次换人之前，找到第一次换人的事件</p>
<p>然后过滤掉：</p>
<ol>
<li>对手的事件</li>
<li>换人之后的事件，也就是index 小于 sub 的事件</li>
<li>失败的传球</li>
</ol>
<pre><code class="language-python">first_sub = events.loc[
    events[&#x27;type_name&#x27;] == &#x27;Substitution&#x27;].loc[
    events[&#x27;team_name&#x27;] == &quot;Arsenal&quot;].iloc[0]
first_sub
</code></pre>
<pre><code>id                         7900f48c-1308-4aa5-9ec8-37af5c06a6d7
index                                                      2335
period                                                        2
timestamp                                       00:21:42.293000
minute                                                       66
                                           ...                 
block_offensive                                             NaN
foul_committed_penalty                                      NaN
foul_won_penalty                                            NaN
bad_behaviour_card_id                                       NaN
bad_behaviour_card_name                                     NaN
Name: 2334, Length: 77, dtype: object
</code></pre>
<pre><code class="language-python">_filter = (
    events.type_name == &#x27;Pass&#x27;) &amp; (
    events.team_name == &quot;Arsenal&quot;) &amp; (
    events.index &lt; first_sub[&#x27;index&#x27;]) &amp; (
    events.outcome_name.isnull())
</code></pre>
<pre><code class="language-python">_filter.head()
</code></pre>
<pre><code>0    False
1    False
2    False
3    False
4     True
dtype: bool
</code></pre>
<pre><code class="language-python"># 获取必要的数据
passes = events.loc[_filter, [
    &#x27;x&#x27;, &#x27;y&#x27;, &#x27;end_x&#x27;, &#x27;end_y&#x27;,
    &#x27;player_id&#x27;, &#x27;player_name&#x27;, &#x27;pass_recipient_name&#x27;, &#x27;pass_recipient_id&#x27;
]]
</code></pre>
<pre><code class="language-python">passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>player_id</th>
      <th>player_name</th>
      <th>pass_recipient_name</th>
      <th>pass_recipient_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>60.0</td>
      <td>40.0</td>
      <td>62.3</td>
      <td>43.5</td>
      <td>15516.0</td>
      <td>Thierry Henry</td>
      <td>Dennis Bergkamp</td>
      <td>15042.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>62.0</td>
      <td>43.5</td>
      <td>47.2</td>
      <td>30.7</td>
      <td>15042.0</td>
      <td>Dennis Bergkamp</td>
      <td>Patrick Vieira</td>
      <td>15515.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>47.2</td>
      <td>29.5</td>
      <td>38.2</td>
      <td>12.1</td>
      <td>15515.0</td>
      <td>Patrick Vieira</td>
      <td>Ashley Cole</td>
      <td>12529.0</td>
    </tr>
    <tr>
      <th>12</th>
      <td>38.2</td>
      <td>12.1</td>
      <td>31.7</td>
      <td>26.3</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>15</th>
      <td>28.8</td>
      <td>29.5</td>
      <td>48.4</td>
      <td>38.8</td>
      <td>15637.0</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>Gilberto Aparecido da Silva</td>
      <td>40221.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>计算位置和大小</h2>
<p>对于每个球员，计算传球和接球的平均位置，然后计算每个球员到接球球员的传球次数，传球线路的粗细与之成正比</p>
<pre><code class="language-python">scatter = pd.DataFrame()
for i, _id in enumerate(passes[&#x27;player_id&#x27;].unique()):
    pass_x = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;x&#x27;].to_numpy()
    pass_y = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;y&#x27;].to_numpy()
    rec_x = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_x&#x27;].to_numpy()
    rec_y = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_y&#x27;].to_numpy()
    scatter.at[i, &#x27;player_id&#x27;] = _id
    
    # 计算每个点的 x 和 y，位置为传球和接球的平均值
    scatter.at[i, &#x27;x&#x27;] = np.mean(np.concatenate([pass_x, rec_x]))
    scatter.at[i, &#x27;y&#x27;] = np.mean(np.concatenate([pass_y, rec_y]))
    
    # 计算传球数
    scatter.at[i, &#x27;count&#x27;] = passes.loc[
        passes[&#x27;player_id&#x27;] == _id].count().iloc[0]
    
# 位置大小
scatter[&#x27;marker_size&#x27;] = scatter[&#x27;count&#x27;] / scatter[&#x27;count&#x27;].max() * 1500
</code></pre>
<pre><code class="language-python">scatter
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_id</th>
      <th>x</th>
      <th>y</th>
      <th>count</th>
      <th>marker_size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>15516.0</td>
      <td>73.757692</td>
      <td>33.834615</td>
      <td>10.0</td>
      <td>306.122449</td>
    </tr>
    <tr>
      <th>1</th>
      <td>15042.0</td>
      <td>66.135897</td>
      <td>37.082051</td>
      <td>15.0</td>
      <td>459.183673</td>
    </tr>
    <tr>
      <th>2</th>
      <td>15515.0</td>
      <td>54.474194</td>
      <td>33.134409</td>
      <td>49.0</td>
      <td>1500.000000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12529.0</td>
      <td>52.920313</td>
      <td>7.568750</td>
      <td>35.0</td>
      <td>1071.428571</td>
    </tr>
    <tr>
      <th>4</th>
      <td>15637.0</td>
      <td>36.142857</td>
      <td>19.846429</td>
      <td>13.0</td>
      <td>397.959184</td>
    </tr>
    <tr>
      <th>5</th>
      <td>40221.0</td>
      <td>52.817460</td>
      <td>43.530159</td>
      <td>32.0</td>
      <td>979.591837</td>
    </tr>
    <tr>
      <th>6</th>
      <td>38412.0</td>
      <td>35.815909</td>
      <td>48.084091</td>
      <td>23.0</td>
      <td>704.081633</td>
    </tr>
    <tr>
      <th>7</th>
      <td>40222.0</td>
      <td>49.040351</td>
      <td>70.389474</td>
      <td>31.0</td>
      <td>948.979592</td>
    </tr>
    <tr>
      <th>8</th>
      <td>19312.0</td>
      <td>61.132308</td>
      <td>18.466154</td>
      <td>32.0</td>
      <td>979.591837</td>
    </tr>
    <tr>
      <th>9</th>
      <td>20015.0</td>
      <td>8.210000</td>
      <td>41.750000</td>
      <td>8.0</td>
      <td>244.897959</td>
    </tr>
    <tr>
      <th>10</th>
      <td>24972.0</td>
      <td>68.381081</td>
      <td>67.370270</td>
      <td>15.0</td>
      <td>459.183673</td>
    </tr>
  </tbody>
</table>
</div>
<h2>球员名及号码</h2>
<p>由于事件数据集只有简单的球员名字和 id，绘制图片时使用名字全称过长，比如 Laureano Bisan-Etame Mayer 这位大哥估计不少人反应不过来是谁，Lauren 就明白了。</p>
<p>需要从另一个数据集中获取</p>
<pre><code class="language-python">lineup = parser.lineup(match_id)
</code></pre>
<pre><code class="language-python">arsenal = lineup.loc[lineup[&#x27;team_name&#x27;] == &#x27;Arsenal&#x27;]
scatter = pd.merge(
    scatter, 
    arsenal[[&#x27;player_id&#x27;, &#x27;player_nickname&#x27;, &#x27;jersey_number&#x27;]], 
    on=&#x27;player_id&#x27;
)
</code></pre>
<h2>计算传球线路宽度</h2>
<p>计算线路宽度，需要根据传球和接球的组合对传球数据框进行分组，并计算他们之间的传球次数。最后一步设置了忽略传球次数少于 2 次的球员的阈值。可以尝试不同的值，根据可视化背后的信息调整它</p>
<pre><code class="language-python"># 计算球员之间的传球次数
passes[&#x27;pair_key&#x27;] = passes.apply(
    lambda x: &#x27;-&#x27;.join(sorted([str(x[&#x27;player_id&#x27;]), 
                               str(x[&#x27;pass_recipient_id&#x27;])])),
    axis=1,
)
lines = passes.groupby([&#x27;pair_key&#x27;]).x.count().reset_index()
lines.rename({&#x27;x&#x27;: &#x27;pass_count&#x27;}, axis=&#x27;columns&#x27;, inplace=True)
</code></pre>
<pre><code class="language-python"># 设定一个阈值，可以尝试研究它在更改时如何变化
lines = lines[lines[&#x27;pass_count&#x27;] &gt; 2]
</code></pre>
<pre><code class="language-python">lines.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>pair_key</th>
      <th>pass_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>12529.0-15515.0</td>
      <td>20</td>
    </tr>
    <tr>
      <th>2</th>
      <td>12529.0-15516.0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12529.0-15637.0</td>
      <td>8</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12529.0-19312.0</td>
      <td>21</td>
    </tr>
    <tr>
      <th>7</th>
      <td>12529.0-40221.0</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
<h2>绘制路线</h2>
<pre><code class="language-python"># 绘制球场
pitch = Pitch(line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0,
)
# 球场上的位置
pitch.scatter(
    scatter.x, scatter.y, s=scatter.marker_size, 
    color=&#x27;red&#x27;, edgecolors=&#x27;grey&#x27;, linewidth=1, alpha=1,
    ax=ax[&#x27;pitch&#x27;], zorder=3,
)

# 填充球员名字
for i, row in scatter.iterrows():
    pitch.annotate(
        row.player_nickname, xy=(row.x, row.y), c=&#x27;black&#x27;, 
        va=&#x27;center&#x27;, ha=&#x27;center&#x27;, weight=&quot;bold&quot;, 
        size=14, ax=ax[&quot;pitch&quot;], zorder=4,
    )
    
for i, row in lines.iterrows():
    player1 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[0])
    player2 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[1])
    
    # 取球员的平均位置在他们之间画一条线
    player1_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;x&#x27;].iloc[0]
    player1_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;y&#x27;].iloc[0]
    player2_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;x&#x27;].iloc[0]
    player2_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;y&#x27;].iloc[0]
    passes_count = row[&#x27;pass_count&#x27;]
    # 调整线宽，传球的次数越多，线越宽
    line_width = passes_count / lines[&#x27;pass_count&#x27;].max() * 10

    pitch.lines(
        player1_x, player1_y, player2_x, player2_y,
        alpha=1, lw=line_width, zorder=2, color=&#x27;red&#x27;, ax=ax[&#x27;pitch&#x27;]
    )
    
fig.suptitle(&#x27;2004-04-25, Tottenham Hotspur vs Arsenal&#x27;, fontsize=30)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/11/1GzYOeHoiubdvLF.png" alt="ARS_VS_HOT_0304_passing_networks.png" /></p>

    </content>
  </entry>
  <entry>
    <title>关于这个博客</title>
    <link href="https://tanzhijian.org/posts/about_blog"></link>
    <id>1680936741.073004</id>
    <updated>2023-04-08T14:52:21Z</updated>
    <published>2023-04-08T14:52:21Z</published>
    <author><name>tanzhijian</name></author>
    <summary>内容没什么好说的，无非就是 GitHub Pages，加上比较懒，样式主题都没改，不过无所谓，以前把博客弄得好看回头文章几年没写一次也不是没有过。
</summary>
    <content type="html">
      <h1>关于这个博客</h1>
<p>内容没什么好说的，无非就是 GitHub Pages，加上比较懒，样式主题都没改，不过无所谓，以前把博客弄得好看回头文章几年没写一次也不是没有过。</p>
<p>但好歹要有一些必须的页面，所以写了一个<a href="https://github.com/tanzhijian/tanzhijian.github.io/blob/master/build.py">脚本</a>生成了 index，archive，以及最重要的 rss，以下是用 ChatGPT 生成的介绍：</p>
<blockquote>
<p>这段代码是一个用 Python 语言写的脚本，可以帮助我们生成一个博客网站。这个博客网站可以展示使用 Markdown 格式编写的博客文章。脚本会读取 &quot;posts&quot; 文件夹中的 Markdown 文件，将它们转换为 HTML 格式，并且使用 Jinja2 模板语言生成 Atom 订阅源、主页和归档页。</p>
<p>代码中定义了一些函数，它们会将 Markdown 文件转换为字典，然后使用 Jinja2 模板渲染字典数据，最终生成网站文件。其中 main 函数是整个程序的主要逻辑，它会读取 Markdown 文件夹中的所有文件，将它们转换为字典并排序，然后将字典数据填充到 Jinja2 模板中，最终生成网站文件。</p>
<p>这个脚本是一个简单的示例，可以作为生成静态网站的基础。</p>
</blockquote>
<p>不足的地方还很多，比如日期是读取文件修改日期，简介只是粗暴的截取第一段填充字数，这些随着使用过程再改了。</p>
<p>关于之后能写的目标，尽量做到避免文章标题复制给 ai 能写出相似更好的内容，这样太糟糕了。</p>

    </content>
  </entry>
  <entry>
    <title>《萤》读书笔记</title>
    <link href="https://tanzhijian.org/posts/firefly"></link>
    <id>1679403673.5903647</id>
    <updated>2023-03-21T21:01:13Z</updated>
    <published>2023-03-21T21:01:13Z</published>
    <author><name>tanzhijian</name></author>
    <summary>翻开这本书时想起了一个小插曲。几年前由于工作原因，需要经常和一个朋友交接，一来二去熟络起来后，偶尔会聊上一些生活。有一次朋友说起正在看一部叫《燃烧》的电影，我没有听说过。
</summary>
    <content type="html">
      <h1>《萤》读书笔记</h1>
<p>翻开这本书时想起了一个小插曲。几年前由于工作原因，需要经常和一个朋友交接，一来二去熟络起来后，偶尔会聊上一些生活。有一次朋友说起正在看一部叫《燃烧》的电影，我没有听说过。</p>
<p>“就是村上春树的小说《烧仓房》改编的。”</p>
<p>“我也没读过《烧仓房》。”</p>
<p>“这。。。你不是很喜欢他吗？”</p>
<p>“不过是个随波逐流的读者罢了。短篇小说陆陆续续读一些，但不记得有这一篇了。”</p>
<p>几天后我收到一个快递，是《萤》这本书。封页写上了一行寄语：“镜子里显现出的，只是表面的真相。”字体秀气。</p>
<p>博尔赫斯的诗。但我并未去想它的含义，也并未去读这本书，很快被我放进书柜了。当时周围不断发生着各种各样的事，应付这些已经精疲力竭，根本没有余力停下步子，等到我再次想起这个朋友时，已经随着工作的变迁渐行渐远了。我仍然能记起朋友说话时永远一副小心翼翼的模样，只是，朋友叫什么名字来着？</p>
<p>言归正传，说回这本书。</p>
<p>《烧仓房》依然是村上春树万年不变的主题，高度发达的资本主义社会与社会边缘人物，这次直白探讨了它们之间的关系。一共有三个人物，我，年轻女孩，她的富哥男朋友，其中我和年轻女孩——一个是无所事事的落魄作家，一个是打零工赚取必要生活开支——社会边缘人物，而富哥男朋友：“做什么不知道，反正就是有钱，谜一样的小伙子。”“简直成了菲茨杰拉德的《了不起的盖茨比》。”</p>
<p>谈到这篇小说的隐喻无非就两个，年轻女孩，以及仓房。富哥男朋友告诉我，他有一种叫做烧仓房的嗜好，就是偷偷地用汽油点燃别人家废弃的仓房，并用望远镜观看火焰。他说这样做是为了维持一种道德上的平衡感。小说中对于仓房的描述：</p>
<blockquote>
<p>海边孤零零的仓房，田地中间的仓房……反正各种各样的仓房。只消十五分钟就烧的一干二净，简直像压根儿不存在那玩意儿。谁都不伤心。只是——消失而已，忽地。</p>
<p>第三处仓房和第四处仓房酷似又老又丑的双胞胎，相距也不过两百米，哪个都那么陈旧那么污秽，甚至叫人觉得要烧索性一起烧掉罢了。</p>
<p>建筑物——我不知道能否称其为建筑物——几乎已经开始解体。的确如他所说，看上去果真像在静等谁来点上一把火。</p>
</blockquote>
<p>社会边缘人物。</p>
<p>故事的最后我碰到了富哥男朋友，他说他已经烧掉了附近最好最值得烧的，但却不是我所找的的任何一个仓房。我还想追问，被他打住了，随后问起年轻女孩的下落，消失了。</p>
<p>我看了很多解读，包括电影《燃烧》，到这里都在讨论，烧仓房只是象征，被真正“烧”掉的是年轻女孩，以及随之而来的阶层固化，上层阶级对于道德甚至法律的话语权，等等。</p>
<p>在我看来本书的结尾处理才是这篇小说仅仅想要表达的主题，一个更绝望的主题：只需要安排一个结局罢了。</p>
<p>至于哪座仓房被真正烧掉了，年轻女孩又是否真的消失了，谁在意呢？</p>

    </content>
  </entry>
  <entry>
    <title>《Football Hackers》读书笔记 04, 瓜迪奥拉</title>
    <link href="https://tanzhijian.org/posts/football_hackers_04"></link>
    <id>1678894701.1364126</id>
    <updated>2023-03-15T23:38:21Z</updated>
    <published>2023-03-15T23:38:21Z</published>
    <author><name>tanzhijian</name></author>
    <summary>这一章主题是革命，足球世界大致符合金钱统治的规律，但有一些手段可以挑战规律，比如挑战现有规则，比如定位球的改进利用，这些大致属于结果倒推过程，就略过了。
</summary>
    <content type="html">
      <h1>《Football Hackers》读书笔记 04, 瓜迪奥拉</h1>
<p>这一章主题是革命，足球世界大致符合金钱统治的规律，但有一些手段可以挑战规律，比如挑战现有规则，比如定位球的改进利用，这些大致属于结果倒推过程，就略过了。</p>
<p>有意思的是一些关于瓜迪奥拉的结论，包括这一章和下一章的:</p>
<blockquote>
<p>瓜迪奥拉以一种独特的方式思考比赛，巴塞罗那是开发新式足球的实验室。他的球队是 4-4-2 还是 4-3-3？基本阵型结构失去了许多相关性；事实上，它们似乎完全融化成一个流动的结构，依靠一系列球场事件和球员任务相互融合。</p>
<p>我们开始了解到，阵型的宽度和固定不再存在。也许它们不再那么重要了，更多的是关于在某些情况下出现的行动原则。他补充，一场比赛的准备让他突然想到了 3-2-4-1。我甚至不知道可以那样比赛。如果不断地尝试寻找更快地转换侧翼或改变传球距离的方法，最终会到达可以排成不同基本阵型的地步。</p>
<p>瓜迪奥拉或图赫尔等教练认为足球是一场不懈的斗争，目的是在接近球、进攻和防守时创造人数上的优势。球场上的空间必须不断地重新占据，以创造传球的选择。图赫尔告诉他的球员们要“尊重空间”。乍一看这听起来很奇怪，但它是为了强调空间是一个动态概念。</p>
<p>空间通常只会动态存在片刻，必须确保你的队友会在你期望的位置。球必须尽可能快、尽可能准确地到达那里。</p>
<p>阵型系统只是使个性发挥作用的框架。它不是死板的，而是一种指导，表明对手哪里有问题，他们为我们留出了空间，他们的球员在战术上没有做正确的事情。它告诉他们在哪里攻击以及如何攻击。我们提供这些模式并在视频中展示它们。我们练习的不多，真的，我们几乎完全专注于训练中的防守动作。我们的进攻来自于不同的模式，在不同的时间，针对不同的对手。重要的是进入这些空间，让我们的球员有机会作为个人脱颖而出。这就是为什么球员必须准确地出现在他们可以做得最好的地方的原因。</p>
<p>他致力于通过比赛位置找到进入禁区并创造优势的方法。他会连续数小时思考问题，有时甚至通宵达旦，并与分析团队讨论。他也会亲自观看比赛，思考策略。有些工作会一直重复，但这是必要的。</p>
<p>功成名就的主教练传记通常详细描述了，经历过狂热的比赛视频研究时期。在这方面，克洛普与瓜迪奥拉和图赫尔没有什么不同，</p>
<p>拜仁的分析师迈克尔尼迈耶告诉我，瓜迪奥拉对数据不感兴趣；他从比赛视频中获取了他需要的所有信息。从字面意义上讲，加泰罗尼亚人不是数据爱好者，而是一个有远见的人：他狂热地寻找通往对手球门的途径，空间和数据优势更容易在影像的帮助下得到改进。</p>
<p>瓜迪奥拉和他那一代人通过观看无数小时的比赛视频来磨练他们的专业知识。</p>
</blockquote>

    </content>
  </entry>
  <entry>
    <title>《刺杀骑士团长》读书笔记</title>
    <link href="https://tanzhijian.org/posts/commendatore"></link>
    <id>1678112227.7996528</id>
    <updated>2023-03-06T22:17:07Z</updated>
    <published>2023-03-06T22:17:07Z</published>
    <author><name>tanzhijian</name></author>
    <summary>大多数人习惯在解读这本小说时带到很高的高度，而在我看来这本小说并没有那么复杂，他有着我读过的村上春树小说中最为平衡的框架，极其顺畅的流程，同时故事也没有到难以理解，只围绕一个主题展开，也就是他的书名，《刺杀骑士团长》的这幅画。
</summary>
    <content type="html">
      <h1>《刺杀骑士团长》读书笔记</h1>
<p>大多数人习惯在解读这本小说时带到很高的高度，而在我看来这本小说并没有那么复杂，他有着我读过的村上春树小说中最为平衡的框架，极其顺畅的流程，同时故事也没有到难以理解，只围绕一个主题展开，也就是他的书名，《刺杀骑士团长》的这幅画。</p>
<p>任何一部小说都需要有一只无形的手来把主角卷入设定好的情节，于是免色涩在故事的前部分挖开了那个象征命运封印的洞，后半部分则换成了秋川真理惠——需要有一面镜子，来反视，或者推敲那些暂且感知不到，视线以外的信息。</p>
<p>而展开一切情节就在于《刺杀骑士团长》的画：</p>
<blockquote>
<p>血从他的胸口喷涌而出。剑的尖端大概刺中了大动脉，血染红他的白色装束。嘴痛得扭歪着，眼睛睁得大大的，万念俱灰的瞪视虚空。他知道自己失败了，但真正的疼痛尚未到来。</p>
<p>另一方的年轻男子眼神极为冷酷，目不转睛的直视对手。眼睛没有悔意，没有困惑与怯懦，没有兴奋表示。瞳仁是那般冷静，眼睛里只有迫在眉睫的一个人的死，以及自己确切无疑的胜利。四溅的血不过是其证明罢了，并未给他带来任何情感。</p>
</blockquote>
<p>这幅充满杀戮信息的画随着不断深入的情节展开了创作背后的故事。作者雨田具彦一九三八年在维也纳参与了一场可能会改变世界线的暗杀，然而失败，他的恋人，地下抵抗组织的成员，被杀害了，而他在可能遭受了非人折磨后遣送回国——从盖世太保手中“抢救出来”。同年他的弟弟在参与了侵华战争，那场大屠杀之后回国，割腕自杀。</p>
<blockquote>
<p>一个除了弹一手好钢琴别无他想的二十岁青年被投入死尸累累的南京战场。</p>
<p>但当时是彻底的军国主义社会，根本没有那样的术语和概念，而仅仅以性格懦弱，没有意志力，缺乏爱国精神处理了事。</p>
</blockquote>
<p>正是这部小说表达的核心，反战，恶，集体之恶。</p>
<p>故事的高潮，主角见到了已经走到生命尽头的雨田具彦，正是他在临终前，通过不断的影响世界把主角卷入其中，他需要他帮他完成刺杀骑士团长这一事件，弥补自己只能寄托于那张画中，毕生都没有做到的那件事，同时因为弟弟在侵华战争中的暴力行为而终身内疚。他将他死前得到救赎的机会拜托给了主角，拿起他已经准备好磨好的刀，刺向那个骑士团长的具象。</p>
<blockquote>
<p>骑士团长失去意识瘫倒之后不久，这位老人也似乎再次耗尽了使得精神集中的力气，就像要说“该看的看清楚了”似的大大吐出一口气，随即闭上眼睛。</p>
<p>看上去他得以重返昏睡那个平稳的世界，那个一无意识二无痛楚的世界。我为他感到欣慰。</p>
</blockquote>
<p>当然了，作为一部四十余万字的小说，丰富程度不仅于此，比如一直不变的“高度发达的资本主义社会与身处边缘却自成一统的价值观和付诸行动的良知勇气”，比如永远“继承”的人物群像模板，这些在读过很多本村上春树小说后变得不那么重要，更何况随着年纪的增大，自己也活成了他笔下那些孤独的配角。值得高兴的是，作为一个已经七十多岁的作者，能感受到他一直精进的笔法和节奏，似乎永远不用担心他成为年纪轻轻的传说——“那甚至是一场噩梦，一旦那样，漫长的人生就只能摩挲着自己的传说来度过，在也没有比那更无聊的人生了。”</p>

    </content>
  </entry>
  
</feed>