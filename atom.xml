<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tanzhijian.org</title>
  <id>https://tanzhijian.org/atom.xml</id>
  <updated>2024-07-24T20:36:43Z</updated>
  <link href="tanzhijian.org"/>
  <link href="https://tanzhijian.org/atom.xml" rel="self"/>
  <generator>?</generator>
  <entry>
    <title>that-game 的可视化功能探讨</title>
    <link href="https://tanzhijian.org/posts/that-game_visualization_explore"></link>
    <id>1721824603.4438024</id>
    <updated>2024-07-24T20:36:43Z</updated>
    <published>2024-07-24T20:36:43Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我发现 that-game 通过设计好的数据格式，或许可以很方便的完成各个级别的可视化
</summary>
    <content type="html">
      <h1>that-game 的可视化功能探讨</h1>
<p>我发现 that-game 通过设计好的数据格式，或许可以很方便的完成各个级别的可视化</p>
<p>文章只为探讨，所有的示例图都为引用的效果图，其具体功能还未实现</p>
<h2>Pitch</h2>
<pre><code class="language-python">pitch = Pitch(length=105, width=68)
pitch.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_pitches_003.png" alt="" /></p>
<pre><code class="language-python">pitch = Pitch(length=105, width=68, vertical=True)
pitch.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_pitches_009.png" alt="" /></p>
<p>这样可以很方便的预览设置的 pitch 是否与自己心目中的一样</p>
<h2>Location</h2>
<p>每一个单独的 Location 都可以单独的查看在 pitch 中的位置</p>
<pre><code class="language-python">location = Location(x=60, y=40, pitch=pitch)
location.show()
</code></pre>
<h2>Event</h2>
<h3>Shot</h3>
<p>可以预览单次射门的状况</p>
<pre><code class="language-python">shot = Shot(...)
shot.show()
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_shot_freeze_frame_001.png" alt="" /></p>
<h3>Pass</h3>
<p>可以预览单次 pass 的传球图，传球方，接球方，球的轨迹，穿过的球员(如果有)</p>
<h3>其他</h3>
<p>其他的一些 type 类我还没有写完，比如 duel, block, dribble, 都会以单点的形式在 pitch 上描绘</p>
<h2>Game</h2>
<p>可以从 game 的角度查看更多</p>
<h3>shots</h3>
<pre><code class="language-python">game = Game(...)
shots = game.shots()
shots.shotmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_scatter_008.png" alt="" /></p>
<h3>passes</h3>
<pre><code class="language-python">passes = game.passes()
passes.network(selected=&#x27;home&#x27;)
</code></pre>
<pre><code class="language-python">passes.passmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_lines_001.png" alt="" /></p>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/Denmark.png" alt="" /></p>
<pre><code class="language-python">passes.passmap(id=&#x27;66&#x27;)
</code></pre>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/TAA.png" alt="" /></p>
<h3>其他</h3>
<pre><code class="language-python">touches = game.touches()
touches.heatmap(selected=&#x27;home&#x27;)
</code></pre>
<p><img src="https://mplsoccer.readthedocs.io/en/latest/_images/sphx_glr_plot_heatmap_001.png" alt="" /></p>
<h3>games</h3>
<p>可以站在 games 集合的角度查看一些统计数据</p>
<pre><code class="language-python">games = Games(Game(...), Game(...), Game(...))
shots = games.shots()
shots.shotmap(team=&#x27;liverpool&#x27;)
</code></pre>
<p><img src="https://soccermatics.readthedocs.io/en/latest/_images/Liverpool_shot_map.png" alt="" /></p>
<pre><code class="language-python">touches = games.touches()
touches.countmap()
</code></pre>
<p>接下来就是设计好用的 api 和参数，以及具体代码实现。坑越挖越大了。</p>

    </content>
  </entry>
  <entry>
    <title>关于 that-game</title>
    <link href="https://tanzhijian.org/posts/about_that_game"></link>
    <id>1720540408.808278</id>
    <updated>2024-07-09T23:53:28Z</updated>
    <published>2024-07-09T23:53:28Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我在一些足球事件的项目中大量使用了 [kloppy](https://github.com/PySport/kloppy), 也有一些项目使用了 [socceraction](https://github.com/ML-KULeuven/socceraction) 的 spadl，这两个都可以看成“标准化的足球事件数据结构”，也就是把各个数据源的事件数据读取成一个统一的数据结构，方便后面的一系列计算。
</summary>
    <content type="html">
      <h1>关于 that-game</h1>
<p>我在一些足球事件的项目中大量使用了 <a href="https://github.com/PySport/kloppy">kloppy</a>, 也有一些项目使用了 <a href="https://github.com/ML-KULeuven/socceraction">socceraction</a> 的 spadl，这两个都可以看成“标准化的足球事件数据结构”，也就是把各个数据源的事件数据读取成一个统一的数据结构，方便后面的一系列计算。</p>
<p>但他们各有各的不方便。socceraction 是基于 pandas，使用 pandera 预设一些字段，也可以做数据验证。既然本质上是个 pd.DataFrame, 就有着 df 不可避免的优点和缺点，数据科学家会很习惯他的操作，但在编写实际代码的时候缺乏很好的自动补全，类型推断，在提供的字段上面也偏少：</p>
<pre><code class="language-python">sbl = StatsBombLoader(root=data_path, getter=&quot;local&quot;)
df_games = sbl.games(competition_id=43, season_id=3).set_index(&quot;game_id&quot;)
game_id = 8657
df_teams = sbl.teams(game_id)
df_players = sbl.players(game_id)
df_events = sbl.events(game_id)

home_team_id = df_games.at[game_id, &quot;home_team_id&quot;]
df_actions = spadl.statsbomb.convert_to_actions(df_events, home_team_id)
</code></pre>
<pre><code class="language-python">df_actions.sample(5)
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>game_id</th>
      <th>original_event_id</th>
      <th>period_id</th>
      <th>time_seconds</th>
      <th>team_id</th>
      <th>player_id</th>
      <th>start_x</th>
      <th>start_y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>type_id</th>
      <th>result_id</th>
      <th>bodypart_id</th>
      <th>action_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2307</th>
      <td>8657</td>
      <td>206ac85d-9b2d-475f-88c7-bc4ccc2738e7</td>
      <td>2</td>
      <td>2482.471</td>
      <td>768</td>
      <td>3308.0</td>
      <td>50.3125</td>
      <td>59.075</td>
      <td>39.8125</td>
      <td>64.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>2307</td>
    </tr>
    <tr>
      <th>168</th>
      <td>8657</td>
      <td>5e1b54a1-a93b-4c78-a69f-4ed8c708dbd9</td>
      <td>1</td>
      <td>346.439</td>
      <td>782</td>
      <td>3101.0</td>
      <td>43.3125</td>
      <td>27.625</td>
      <td>42.4375</td>
      <td>28.475</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>168</td>
    </tr>
    <tr>
      <th>938</th>
      <td>8657</td>
      <td>19d08ada-edbc-4fe6-bfd3-00aa03977447</td>
      <td>1</td>
      <td>1821.052</td>
      <td>768</td>
      <td>3468.0</td>
      <td>98.4375</td>
      <td>30.175</td>
      <td>97.5625</td>
      <td>30.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>938</td>
    </tr>
    <tr>
      <th>2310</th>
      <td>8657</td>
      <td>fe9150f6-60d7-429b-8116-115f1b49a1b8</td>
      <td>2</td>
      <td>2489.351</td>
      <td>782</td>
      <td>3077.0</td>
      <td>25.8125</td>
      <td>65.025</td>
      <td>31.9375</td>
      <td>64.175</td>
      <td>21</td>
      <td>1</td>
      <td>0</td>
      <td>2310</td>
    </tr>
    <tr>
      <th>903</th>
      <td>8657</td>
      <td>9f489405-7d17-4a0b-9c77-089c49e0b056</td>
      <td>1</td>
      <td>1770.533</td>
      <td>782</td>
      <td>3176.0</td>
      <td>65.1875</td>
      <td>4.675</td>
      <td>65.1875</td>
      <td>12.325</td>
      <td>0</td>
      <td>1</td>
      <td>5</td>
      <td>903</td>
    </tr>
  </tbody>
</table>
</div>
<p>读取过程稍显麻烦，一些在我看来的重要信息，比如 team，player，type， result， bodypart 等都是使用数字作为类别，不存在可读性，如果想要搞清楚数字代表的具体含义需要再调用一个函数：</p>
<pre><code class="language-python">from socceraction.spadl import results_df

results_df()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>result_id</th>
      <th>result_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>fail</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>success</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>offside</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>owngoal</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>yellow_card</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5</td>
      <td>red_card</td>
    </tr>
  </tbody>
</table>
</div>
<p>都是可哈希对象，其实可以使用字符串使其更具有可读性。而且 spadl 作为为这个库主要的目的，计算 xT, VAEP 的数据结构，支持的 type 也偏少。</p>
<p>kloppy 是则是使用了更为灵活的基于对象的数据模型，有更多的预设读取，如果你只是用他预设的数据源进行操作没什么问题，想更多的自定义操作，他的数据类使用 python dataclass，就没办法有很好的数据验证:</p>
<pre><code class="language-python">from kloppy.domain import Team, Ground

# 这个是正确输入
team = Team(team_id=&quot;ars&quot;, name=&quot;Arsenal&quot;, ground=Ground.HOME)

# 但即使输入一些错误的类型也不会有问题
team = Team(team_id=123, name=123, ground=&quot;HOME&quot;)
</code></pre>
<p>只能通过 mypy 之类的工具寄希望于代码执行之前检查类型，并不具有强制性。同时如果想自定义创建一个 EventDataset 需要太多步骤：</p>
<pre><code class="language-python">from kloppy.domain import (
    BallState,
    DatasetFlag,
    EventDataset,
    Ground,
    KloppyCoordinateSystem,
    Metadata,
    Orientation,
    Period,
    PitchDimensions,
    Player,
    Point,
    Provider,
    ShotEvent,
    ShotResult,
    Team,
)
</code></pre>
<pre><code class="language-python">period = Period(id=1, start_timestamp=0.0, end_timestamp=2827.0)
team = Team(team_id=&quot;ars&quot;, name=&quot;Arsenal&quot;, ground=Ground.HOME)
team_2 = Team(team_id=&quot;che&quot;, name=&quot;Chelsea&quot;, ground=Ground.AWAY)
player = Player(player_id=&quot;saka&quot;, team=team, jersey_no=7, name=&quot;Bukayo Saka&quot;)
coordinates = Point(x=100, y=50)
event = ShotEvent(
    event_id=&quot;1&quot;,
    period=period,
    timestamp=217.32,
    team=team,
    player=player,
    coordinates=coordinates,
    result=ShotResult.OFF_TARGET,
    raw_event=None,
    ball_state=BallState.ALIVE,
    ball_owning_team=team,
    related_event_ids=[],
    state={},
    qualifiers=[],
    freeze_frame=None,
)
</code></pre>
<pre><code class="language-python">pitch_dimensions = PitchDimensions(x_dim=108, y_dim=68)
coordinate_system = KloppyCoordinateSystem(normalized=True, length=108, width=68)
metadata = Metadata(
    teams=[team, team_2],
    periods=[period],
    pitch_dimensions=pitch_dimensions,
    orientation=Orientation.ACTION_EXECUTING_TEAM,
    flags=DatasetFlag.BALL_OWNING_TEAM,
    provider=Provider.OTHER,
    coordinate_system=coordinate_system,
)
</code></pre>
<pre><code class="language-python">custom_dataset = EventDataset(records=[event], metadata=metadata)
</code></pre>
<p>他在描述状态的时候用了大量的 enum，每一个都需要导入，以及确定每一个字段的含义。而我使用最不舒服的一点在构建 team 和 player，他在设计时使用了循环引用:</p>
<pre><code class="language-python">@dataclass
class Player:
    team: &quot;Team&quot;

@dataclass
class Team:
    players: List[Player] = field(default_factory=list)
</code></pre>
<p>可以读他源代码中读取 statsbomb 的一段：</p>
<pre><code class="language-python">        def create_team(lineup, ground_type):
            team = Team(
                team_id=str(lineup[&quot;team_id&quot;]),
                name=lineup[&quot;team_name&quot;],
                ground=ground_type,
                starting_formation=starting_formations[lineup[&quot;team_id&quot;]],
            )
            team.players = [
                Player(
                    player_id=str(player[&quot;player_id&quot;]),
                    team=team,
                    name=player[&quot;player_name&quot;],
                    jersey_no=int(player[&quot;jersey_number&quot;]),
                    starting=str(player[&quot;player_id&quot;]) in player_positions,
                    position=player_positions.get(str(player[&quot;player_id&quot;])),
                )
                for player in lineup[&quot;lineup&quot;]
            ]
            return team
</code></pre>
<p>循环引用有什么后果不多讨论，单从使用上来说，需要先创建 team，然后创建 player，把 team 塞到 player，再把 player 塞到 team。</p>
<p>在使用那么久之后，我还是想自己创建一个 Events 的数据格式，便写了 that-game。</p>
<p>我中和了上面两个库的特性，以及长期的使用习惯，that-game 需要有以下的特点：</p>
<ul>
<li>创建简单</li>
<li>方便计算</li>
<li>尽可能的扁平化</li>
<li>支持数据验证</li>
<li>支持类型推断</li>
<li>预设常用的数据源读取</li>
<li>方便导出为常用格式</li>
<li>方便不同的数据规格（主要是坐标）转换</li>
<li>兼容尽可能多的事件类型</li>
<li>方便不同数据源之间匹配和融合</li>
<li>可读性</li>
</ul>
<p>使用 pydantic 来创建数据类可以解决大部分，常用状态使用 typing.Literal 预设字段，既能很好的配合编辑器补全，也能通过 pydantic 进行输入验证。</p>
<p>在创建新对象的时候，可以导入每个数据类，嫌麻烦也可以这样：</p>
<pre><code class="language-python">from that_game import Shot

shot = Shot(
    id=&quot;0001&quot;,
    type=&quot;shot&quot;,
    period=&quot;first_half&quot;,
    seconds=62.0,
    team={&quot;id&quot;: &quot;ars&quot;, &quot;name&quot;: &quot;Arsenal&quot;},
    player={&quot;id&quot;: &quot;a7&quot;, &quot;name&quot;: &quot;Bukayo Saka&quot;, &quot;position&quot;: &quot;FW&quot;},
    location={
        &quot;x&quot;: 100.1,
        &quot;y&quot;: 43.2,
        &quot;pitch&quot;: {&quot;length&quot;: 108, &quot;width&quot;: 68},
    },
    end_location={
        &quot;x&quot;: 108.0,
        &quot;y&quot;: 43.2,
        &quot;pitch&quot;: {&quot;length&quot;: 108, &quot;width&quot;: 68},
    },
    pattern=&quot;open_play&quot;,
    body_part=&quot;left_foot&quot;,
    result=&quot;saved&quot;,
)
</code></pre>
<p>每个数据源之间最大的差异便是坐标系统，使用球场长宽高不同，方向不同，如何方便的转换是一个很大的问题，that-game 的 Location 可以很直观方便的转换：</p>
<pre><code class="language-python">from that_game import Location, Pitch

location = Location(
    x=0.4,
    y=0.6,
    pitch=Pitch(length=1, width=1),
)

# 只需要设定好新的 pitch 标准
pitch = Pitch(
    length=100,
    width=100,
    length_direction=&quot;left&quot;,
    width_direction=&quot;down&quot;,
)
location.transform(pitch)
print(location.x, location.y)
</code></pre>
<pre><code>60.0 40.0
</code></pre>
<p>我会在完善 Location 类后添加更多的预设 pitch，更加方便转换。</p>
<p>目前支持的 type 仅有 shot 和 pass，支持的数据源也仅是 statsbomb，同时还有一个 fusion-events 的调试项目，在这里可以通过网络请求获取一些网站，比如 understat 的 events 进行操作。之后的工作重点便是添加更多的事件类型，添加更多的事件状态，添加更多的字段，比如 shot 预设计算 distance 和 angle, 以及不断调整它们之间的兼容性，更多的 loaders。这个库的难点不在于复杂度，而在于取舍，和更方便的使用。大概会用一年的时间让他变得可用吧。</p>

    </content>
  </entry>
  <entry>
    <title>open-data events 文档笔记</title>
    <link href="https://tanzhijian.org/posts/ope_data_events"></link>
    <id>1719315575.7717075</id>
    <updated>2024-06-25T19:39:35Z</updated>
    <published>2024-06-25T19:39:35Z</published>
    <author><name>tanzhijian</name></author>
    <summary>原文档 pdf 不方便查阅特做整理, 机器翻译手动整理结构
</summary>
    <content type="html">
      <h1>open-data events 文档笔记</h1>
<p>原文档 pdf 不方便查阅特做整理, 机器翻译手动整理结构</p>
<p>v4.0</p>
<p>本文档描述了StatsBomb开放事件数据的JSON格式。</p>
<h2>Format</h2>
<p>data/events 目录中的比赛文件将采用 JSON 格式。文件名将采用 1234.json 格式，其中 1234 是比赛 ID。内容是一个包含两支球队的事件信息的数组。一些元素有子元素（通常是名称/ID 对）或子数组（这些将在文档后面详细介绍）。</p>
<ul>
<li>
<p>id: uuid, 每个事件的唯一标识符</p>
</li>
<li>
<p>index: int, 每场比赛中事件排序的序列符号。自增的整数</p>
</li>
<li>
<p>preiod: int, 时间戳对应的比赛部分</p>
<ul>
<li>1: 1st Half</li>
<li>2: 2nd Half</li>
<li>3: 3rd Period</li>
<li>4: 4th Period</li>
<li>5: Penalty Shootout</li>
</ul>
</li>
<li>
<p>timestamp: timestamp, 比赛中事件发生的时间，精确到毫秒。</p>
</li>
<li>
<p>minute: int, 事件发生时时钟上的分钟数。半场结束时重置为 45 分钟，加时赛开始时重置为 90 分钟。</p>
</li>
<li>
<p>second: int, timestamp 的第二部分</p>
</li>
<li>
<p>type: object, (id: int, name: str), event 事件类型的 ID/名称。</p>
<ul>
<li>42, Ball Receipt, 接到传球</li>
<li>2, Ball Recovery, 尝试夺回球权</li>
<li>3, Dispossessed, 球员被防守球员拦截而带球失败，因此丢失球权</li>
<li>4, Duel, 比赛中对立双方两名球员之间 50 对 50 的较量</li>
<li>5, Camera On, 发出信号停止摄像机捕捉比赛过程以进行重播/视频剪辑</li>
<li>6, Block, 站在球的路径上阻挡球</li>
<li>8, Offside, 越位。由射门或解围（非传球）导致的事件。对于造成越位的传球，请查看传球部分</li>
<li>9, Clearance, 防守球员为消除危险而采取的行动，并非有意将球传给队友</li>
<li>10, Interception, 通过移动到传球路线/做出反应进行拦截，阻止对手的传球到达队友手中</li>
<li>14, Dribble, 球员试图带球突破对手</li>
<li>16, Shot, 用身体任何（合法）部位试图进球</li>
<li>17, Pressure, 对接球、带球或传球的对方球员施加压迫</li>
<li>18, Half Start, 裁判吹哨开始一个部分的比赛</li>
<li>19, Substitution</li>
<li>20, Own Goal Against, 对方球员的乌龙球</li>
<li>21, Foul Won, 犯规获胜的定义是，一名球员在遭到对方球员犯规后，为本队赢得任意球或点球</li>
<li>22, Foul Committed, 任何被裁判判为犯规的违规行为, 越位不被视为犯规</li>
<li>23, Goal Keeper, 守门员可以执行的动作</li>
<li>24, Bad Behaviour, 当球员由于比赛之外的违规行为而收到黄牌时</li>
<li>25, Own Goal For, 该队进了一粒乌龙球</li>
<li>26, Player On, 球员离开事件发生后，球员返回球场</li>
<li>27, Player Off, 一名球员未经替换就离开/被抬出球场</li>
<li>28, Shield, 球员保护出界的球以防止对手继续比赛</li>
<li>30, Pass, 球在队友之间传递</li>
<li>33, 50/50, 两名球员争夺无球权的球</li>
<li>34, Half End, 向裁判发出哨声，表示某一场比赛部分结束</li>
<li>35, Starting XI, 标明首发 11 名球员、他们的位置以及球队阵型</li>
<li>36, Tactical Shift, 表示球队的战术变化，显示球员的新位置和球队的新阵型</li>
<li>37, Error, 当一名球员被判定犯下控球失误，从而导致射门时</li>
<li>38, Miscontrol, 球员因触球失误丢球</li>
<li>39, Dribbled Past, 球员被对手带球突破</li>
<li>40, Injury Stoppage, 因受伤而停止比赛</li>
<li>41, Referee Ball-Drop, 因伤病暂停后，裁判放下球，继续比赛</li>
<li>43, Carry, 球员在移动或站立时控制脚下的球</li>
</ul>
</li>
<li>
<p>possession: int, 表示比赛中当前唯一的一次控球。一次控球表示在比赛期间，球处于比赛状态，并且由一支球队控制球</p>
</li>
<li>
<p>possession_team: object, (id: int), 开始控球的球队的 ID。请注意，即使在控球期间试图铲球等对手事件中，此 ID 也会显示</p>
</li>
<li>
<p>play_pattern: object, (id: int, name: str), 与此事件相关的比赛模式的 ID/名称</p>
<ul>
<li>1, Regular Play, 该事件不属于以下任何 play_patterns</li>
<li>2, From Corner, 该事件是角球之后比赛进程的一部分</li>
<li>3, From Free Kick, 该事件是任意球之后比赛过程的一部分</li>
<li>4, From Throw In, 此事件是界外球之后比赛过程的一部分</li>
<li>5, Other</li>
<li>
6, From Counter 该事件是反击的一部分:<ul>
<li>控球开始于反击球队最后三分之一区域外的一次常规比赛失误</li>
<li>控球至少有 75% 直接朝向球门（以我们的控球链指标衡量）</li>
<li>反击向球门前进了至少 18 码。</li>
<li>此定义不是收集的一部分，而是从上述逻辑中得出的</li>
</ul>
</li>
<li>7, From Goal Kick, 该事件是球门球后比赛过程的一部分</li>
<li>8, From Keeper, 这一事件是守门员开球后比赛进程的一部分</li>
<li>9, From Kick Off, 该事件是开球后比赛进程的一部分</li>
</ul>
</li>
<li>
<p>team: object, (id: int, name: str), 此事件所关联的球队的 ID/名称。仅当事件与特定球队相关时，才会显示对象</p>
</li>
<li>
<p>player: object, (id: int, name: str), 与该事件相关的球员的 ID/名称（仅当事件与特定球员相关时才会显示对象）</p>
</li>
<li>
<p>position: object, (id: int, name: str), 事件发生时球员所处位置的 ID / 名称</p>
<ul>
<li>1, GK, Goalkeeper</li>
<li>2, RB, Right Back</li>
<li>3, RCB, Right Center Back</li>
<li>4, CB, Center Back</li>
<li>5, LCB, Left Center Back</li>
<li>6, LB. Left Back</li>
<li>7, RWB, Right Wing Back</li>
<li>8, LWB, Left Wing Back</li>
<li>9, RDM, Right Defensive Midfield</li>
<li>10, CDM, Center Defensive Midfield</li>
<li>11, LDM, Left Defensive Midfield</li>
<li>12, RM, Right Midfield</li>
<li>13, RCM, Right Center Midfield</li>
<li>14, CM, Center Midfield</li>
<li>15, LCM, Left Center Midfield</li>
<li>16, LM, Left Midfield</li>
<li>17, RW, Right Wing</li>
<li>18, RAM, Right Attacking Midfield</li>
<li>19, CAM, Center Attacking Midfield</li>
<li>20, LAM, Left Attacking Midfield</li>
<li>21, LW, Left Wing</li>
<li>22, RCF, Right Center Forward</li>
<li>23, ST, Striker</li>
<li>24, LCF, Left Center Forward</li>
<li>25, SS, Sencondary Striker</li>
</ul>
</li>
<li>
<p>location: array, (x: int, y: int), 包含两个整数值的数组。这些是事件的 x 和 y 坐标（仅当事件具有高度坐标时才显示）</p>
</li>
<li>
<p>duration: float, 如果相关，则事件持续的时间（以秒为单位）</p>
</li>
<li>
<p>under_pressure: bool, 该动作是在对手施加压力的情况下做出的</p>
</li>
<li>
<p>off_camera: bool: 事件发生时，摄像机处于关闭状态</p>
</li>
<li>
<p>out, bool, 如果事件的结果是球出界，则添加</p>
</li>
<li>
<p>related_events: <code>array[uuid]</code>, 相关事件 ID 的逗号分隔列表。例如，射门可能与守门员事件和拦截事件相关。相应事件的 related_events 列中将包含射门的 ID</p>
</li>
<li>
<p>tactics: object</p>
<ul>
<li>formation: int, 对于“首发 XI 或战术换班”类型的事件，添加了“战术”对象。阵型项目描述了正在使用的阵型, 433</li>
<li>lineup: <code>array[player: object[id: int, name: str], position: object[id: int, name: str], jersey_number: int]</code>, 对于“首发 XI 或战术换人”类型的事件，添加了“战术”对象。阵容项描述了球员及其位置</li>
</ul>
</li>
</ul>
<h2>Event Type Objects</h2>
<p>如果事件属于具有附加详细信息的类型，则这些详细信息将嵌套在以该事件类型命名的对象中。例如，Shot 类型的事件将具有嵌套数据框，其中包含描述该事件类型的附加变量。以下是按字母顺序排列的嵌套数据框列表及其包含的变量。</p>
<ul>
<li>
<p>50-50</p>
<ul>
<li>
outcome: object, (id: int, name: str), 50 50争夺结果的ID/名称, values:<ul>
<li>108, Won</li>
<li>109, Lost</li>
<li>147, Success To Team, 球员赢得 50/50 并将球控制到己方</li>
<li>148, Success To Opposition, 球员赢得 50/50，但将球踢到对方</li>
</ul>
</li>
<li>counterpress: bool, 在 open play 转换后 5 秒内采取压迫</li>
</ul>
</li>
<li>
<p>Bad Behaviour: object, (id: int, name: str), 红黄牌的 ID/名称</p>
<ul>
<li>65, Yellow Card</li>
<li>66, Second Yellow</li>
<li>67, Red Card</li>
</ul>
</li>
<li>
<p>Ball Receipt: object, (id: int, name: str), 指定球接收结果的属性选项的 ID/名称</p>
<ul>
<li>9, Incomplete</li>
</ul>
</li>
<li>
<p>Ball Recovery
offensive: bool, 如果恢复进攻则添加
recovery_failure: bool: 如果恢复失败则添加</p>
</li>
<li>
<p>Block</p>
<ul>
<li>deflection: bool, 如果是偏转则添加</li>
<li>offensive: bool, 如果该阻挡具有攻击性则添加</li>
<li>save_block: bool, 如果阻挡了射门则添加</li>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Carry</p>
<ul>
<li>end_location: array, (x: int, y: int)</li>
</ul>
</li>
<li>
<p>Clearance</p>
<ul>
<li>aerial_won: bool, 如果高空解围则添加</li>
<li>
body_part: object, (id: int, name: str), 触球身体部位的 ID/名称<ul>
<li>37, Head</li>
<li>38, Left Foot</li>
<li>40, Right Foot</li>
<li>70, Other</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dribble</p>
<ul>
<li>Overrun: bool, 当球越过原来的防守队员进入另一名球员的球权时添加</li>
<li>Nutmeg: bool, 当球从对方球员腿间穿过时添加</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>8, Complete</li>
<li>9, Incomplete</li>
</ul>
</li>
<li>No Touch: bool, 如果球员试图通过将球漏过对手而不是接触球来进行带球</li>
</ul>
</li>
<li>
<p>Dribbled Past</p>
<ul>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Duel</p>
<ul>
<li>counterpress: bool</li>
<li>
type: object, (id: int, name: str), Id/Name 为对抗的类型<ul>
<li>10, Aerial Lost, 争夺空中对抗但没能抢到球</li>
<li>11, Tackle, 抢断对方球员的控球权</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str), 对抗结果的 Id/名称<ul>
<li>1， Lost</li>
<li>4, Won, 抢断最终落入抢断队员手中</li>
<li>13, Lost In Play, 将球踢向对手的抢断</li>
<li>14, Lost Out, 铲球将球击出界外，有利于对手</li>
<li>15, Success</li>
<li>16, Success In Play, 将球传给队友的抢断</li>
<li>17， Success Out, 抢断将球击出界外，有利于抢断者的球队</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Foul Committed</p>
<ul>
<li>counterpress: bool</li>
<li>offensive: bool</li>
<li>
type: object, (id: int, name: str), Id/Name 为犯规的类型<ul>
<li>19, 6 Seconds, 因 6 秒违例被判犯规</li>
<li>20, Backpass Pick, 因回传用手接球违例被判犯规</li>
<li>21, Dangerous Play, 危险动作导致犯规</li>
<li>22, Dive, 因假摔而犯规</li>
<li>23, Foul Out, 因犯规被罚出场</li>
<li>24, Handball, 手球犯规</li>
</ul>
</li>
<li>advantage: bool, 如果裁判判定为进攻有利比赛继续则添加</li>
<li>penalty: bool, 如果被判点球添加</li>
<li>
card: object, (id: int, name: str), 卡牌的类型<ul>
<li>5, Yellow Card</li>
<li>6, Second Yellow</li>
<li>7, Red Card</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Foul Won</p>
<ul>
<li>defensive: bool, 如果在失去控球权的情况下犯规，则添加</li>
<li>advantage: bool, 如果裁判判定为进攻有利比赛继续则添加</li>
<li>penalty: bool, 如果判罚点球则添加</li>
</ul>
</li>
<li>
<p>GoalKeeper</p>
<ul>
<li>
position: object, (id: int, name: str), 守门员射门前站位选项的 ID/名称<ul>
<li>42, Moving, 射门时守门员正在移动</li>
<li>43, Prone, 射门时守门员倒在地上</li>
<li>44, Set, 射门时守门员处于静止状态</li>
</ul>
</li>
<li>
technique: object, (id: int, name: str), 守门员使用的技术技术选项的 ID/名称<ul>
<li>45, Diving, 守门员飞身进行扑救</li>
<li>46, Standing, 守门员站立进行扑救</li>
</ul>
</li>
<li>
body_part: object, (id: int, name: str), 守门员扑救时使用的身体部位<ul>
<li>35, Both Hands</li>
<li>36, Chest</li>
<li>37, Head</li>
<li>38, Left Foot</li>
<li>39, Left Hand</li>
<li>40, Right Foot</li>
<li>41, Right Hand</li>
</ul>
</li>
<li>
type: object, (id: int, name: str), 指定守门员事件类型的 ID/名称。每次射门都会有一个相关的守门员事件。如果没有失球或没有扑救，守门员类型将为“Shot Faced”）<ul>
<li>25, Collected</li>
<li>26, Goal Conceded, 失球</li>
<li>27, Keeper Sweeper, 当守门员离开自己的防线和/或禁区扑球时</li>
<li>28, Penalty Conceded, 守门员在点球中失球</li>
<li>29, Penalty Saved</li>
<li>30, Punch, 守门员拳击球（类似清球）</li>
<li>31, Save, 守门员扑救非射门</li>
<li>32, Shot Faced, 射门未导致扑救或失球</li>
<li>33, Shot Saved, 守门员扑出对方射门</li>
<li>34, Smother, 相当于禁区外球员的抢断，守门员出来抢断球员</li>
<li>113, Shot Saved Off T, 守门员扑出了对方偏离目标的射门</li>
<li>114, Shot Saved To Post, 射门被守门员扑出，击中门柱</li>
<li>110, Saved To Post, 守门员扑救非射门击中门柱</li>
<li>109, Penalty Saved To Post</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>47, Claim, 守门员清道夫动作，但是接住了球</li>
<li>48, Clear, 守门员清道夫动作，但是清除了球</li>
<li>49, Collected Twice, 守门员在第一次接球失误后，又多次尝试接球</li>
<li>50, Fail, 动作失败</li>
<li>51, In Play, 守门员扑救，将球挡回场内</li>
<li>52, In Play Danger, 守门员扑救，将球挡给对方球员</li>
<li>53, In Play Safe, 守门员扑救，将球挡给队友</li>
<li>55, No Touch, 守门员未触球就丢球</li>
<li>56, Saved Twice, 守门员在第一次扑救失败后，又多次尝试扑救</li>
<li>15, Success</li>
<li>58, Touched In, 尽管守门员触球，但还是丢球</li>
<li>59, Touched Out, 守门员触球出界</li>
<li>4, Won, 获得球权</li>
<li>16, Success In Play, 将球传给队友的扑救</li>
<li>17, Success Out, 将球扑出界外，有利于拦截方的球队</li>
<li>13， Lost In Play, 将球击向对手的扑救</li>
<li>14, Lost Out, 将球击出界外，有利于对手</li>
<li>117, Punched Out, 守门员将球扑出界外</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Half End</p>
<ul>
<li>Early Video End: bool, 如果比赛视频不完整且比赛在本节结束前结束，则添加</li>
<li>Match Suspended: bool, 裁判决定结束或推迟比赛</li>
</ul>
</li>
<li>
<p>Half Start</p>
<ul>
<li>Late Video Start: bool, 如果比赛视频未完成并在开球后开始，则添加</li>
</ul>
</li>
<li>
<p>Injury Stoppage</p>
<ul>
<li>in_chain: bool, 如果比赛暂停前球在受伤球员的球队手中，则添加</li>
</ul>
</li>
<li>
<p>Interception</p>
<ul>
<li>
outcome, object, (id: int, name: str)<ul>
<li>1, Lost</li>
<li>13, Lost In Play, 将球击给对手的拦截</li>
<li>14, Lost Out, 拦截将球击出界外，有利于对方</li>
<li>15, Success</li>
<li>16, Success In Play, 将球传给队友的拦截</li>
<li>17, Success Out, 拦截将球击出界外，有利于拦截方的球队</li>
<li>4, Won, 拦截后球落入拦截者手中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Miscontrol</p>
<ul>
<li>aerial_won: bool, 如果事件发生在空中，则添加</li>
</ul>
</li>
<li>
<p>Pass</p>
<ul>
<li>recipient: object, (id: int, name: str), Id / Name 传球接收者的球员，或未完成传球的接收者的球员</li>
<li>length: float, 以码为单位的传球长度, 16.03</li>
<li>angle: float, 以弧度表示的通过角度，其中 0 指向正前方，0 到 π 之间的正值表示顺时针方向的角度，0 到 -π 之间的负值表示逆时针方向的角度, -2.49</li>
<li>
height: object, (id: int, name: str), 传球高度的 ID / 名称<ul>
<li>1, Ground Pass, 球没有离开地面</li>
<li>2, Low Pass, 球离开地面但在最高高度时低于肩膀的高度</li>
<li>3, High Pass, 球在最高高度超过肩膀的高度</li>
</ul>
</li>
<li>end_location: array, (x: int, y: int)</li>
<li>assisted_shot_id: uuid, 如果这次传球是助攻，那么关联射门的事件 id</li>
<li>backheel: bool, 如果用脚后跟传球则添加</li>
<li>deflected: bool, 如果传球偏转则添加</li>
<li>miscommunication: bool, 如果传球存在沟通不畅则添加</li>
<li>cross: bool, 如果传球是传中则添加</li>
<li>cut-back: bool, 如果传球是回传则添加</li>
<li>switch: bool, 如果传球是转移（球垂直转移了至少 50% 的球场），则添加</li>
<li>shot-assist: bool, 如果传球是对射门的助攻（但未进球），则添加</li>
<li>goal-assist: bool, 如果传球助攻进球，则添加</li>
<li>
body-part: object, (id: int, name: str)<ul>
<li>68, Drop Kick, 传球来自守门员的 drop kick</li>
<li>37, Head, 传球来自头球</li>
<li>69, Keeper Arm, 传球来自守门员的手手抛球</li>
<li>38, Left Foot</li>
<li>70, Other</li>
<li>40, Right Foot</li>
<li>106, No Touch, 一名球员故意让球从自己身边经过，而不是接球，而是传给身后的队友。也称为“假动作”）。</li>
</ul>
</li>
<li>
type: object, (id: int, name: str)<ul>
<li>61, Corner</li>
<li>62, Free Kick</li>
<li>63, Goal Kick</li>
<li>64, Interception</li>
<li>65, Kick Off, 比赛开始时或得分后开球时的传球</li>
<li>66, Recovery, 一触式传球抢断</li>
<li>67, Throw-in</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>9, Incomplete, 球未到达队友，比赛仍在进行中</li>
<li>74, Injury Clearance, 因受伤而停止比赛，球出界</li>
<li>75, Out, 球出界</li>
<li>76, Pass Offside, 球传到队友手中但传球被判越位</li>
<li>77, Unknown, 结果未知（即在飞行过程中被判犯规）</li>
</ul>
</li>
<li>
Technique: object, (id: int, name: str), 传球技术的 ID / 名称<ul>
<li>104, Inswinging, 适用于内旋高/低角球</li>
<li>105, Outswinging, 适用于外旋高/低角球</li>
<li>107, Straight, 不适用于内旋角球或外旋角球</li>
<li>108, Through Ball, 传球突破最后一道防线</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Player Off</p>
<ul>
<li>Permanent: bool, 如果球员永久离开比赛，则添加。适用于没有替补球员但球员因伤无法重返球场的情况</li>
</ul>
</li>
<li>
<p>Pressure</p>
<ul>
<li>counterpress: bool, 在常规比赛转换后 5 秒内采取紧逼行动</li>
</ul>
</li>
<li>
<p>Shot</p>
<ul>
<li>key_pass_id: uuid</li>
<li>end_location: array, (x: int, y: int)</li>
<li>aerial_won: bool, 如果射门是空中胜利，则添加</li>
<li>follows_dribble: bool, 如果射门是在盘带后进行的，则添加</li>
<li>first_time: bool, 如果射门是第一次触球，则添加</li>
<li>freeze_frame: array, 每次射门都包含一个名为 freeze_frame 的对象，该对象是一个数组，其中包含射门时相关球员的信息，每个 freezeframe 对象都是一个数据框，每个球员占一行，包括他们的位置、球队、ID、姓名以及位置 ID 和姓名</li>
<li>open_goal: bool, 如果射门是在空门的情况下进行的，则添加</li>
<li>statsbomb_xg: float</li>
<li>deflected: bool, 如果射门偏出则添加</li>
<li>
technique: object, (id: int, name: str), 射门技术的 ID / 名称<ul>
<li>89, Backheel</li>
<li>90, Diving Header</li>
<li>91, Half Volley, 半临空</li>
<li>92, Lob, 为了越过对方球员而射出的球具有较高的弧线</li>
<li>93, Normal, 不属于任何其他技术的射门</li>
<li>94, Overhead Kick</li>
<li>95, Volley</li>
</ul>
</li>
<li>
body_part: object, (id: int, name: str)<ul>
<li>37, Head</li>
<li>38, Laft Foot</li>
<li>70, Other</li>
<li>40, Right Foot</li>
</ul>
</li>
<li>
type: object, (id: int, name: str)<ul>
<li>61, Corner</li>
<li>62, Free Kick</li>
<li>87, Open Play</li>
<li>88, Penalty</li>
<li>65, Kick Off, 开球后直接射门</li>
</ul>
</li>
<li>
outcome: object, (id: int, name: str)<ul>
<li>96, Blocked</li>
<li>97, Goal</li>
<li>98, Off T</li>
<li>99, Post</li>
<li>100, Saved</li>
<li>101, Wayward, 射门毫无威胁，偏离球门太远或力量不足以到达球门线（或球员没有碰到球的失误）</li>
<li>115, Saved Off T</li>
<li>116, Saved To Post</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Substitution</p>
<ul>
<li>replacement: object, (id: int, name: str), 对于替换，上场球员的 ID/姓名。球员详情（主要事件）描述下场球员。</li>
<li>
outcome: object, (id: int, name: str), 替换类型选项的 Id/Name<ul>
<li>102, Injury</li>
<li>103, Tactical</li>
</ul>
</li>
</ul>
</li>
</ul>

    </content>
  </entry>
  <entry>
    <title>我所设想的 fusion-stat 数据模型</title>
    <link href="https://tanzhijian.org/posts/fusion-stat-model-refactoring-ideas"></link>
    <id>1712469841.6559868</id>
    <updated>2024-04-07T14:04:01Z</updated>
    <published>2024-04-07T14:04:01Z</published>
    <author><name>tanzhijian</name></author>
    <summary>目前 fusion-stat 模型总共分为 Competitions, Competition, Team, Staff, Player, Matches, Match, 他们之间自成一派，并没有什么关联，且最大的问题是数据规则是写死的，即开发者制定了所有的规则，用户能修改或定制的部分很少，要么便是自己 import spiders 来重写。
</summary>
    <content type="html">
      <h1>我所设想的 fusion-stat 数据模型</h1>
<p>目前 fusion-stat 模型总共分为 Competitions, Competition, Team, Staff, Player, Matches, Match, 他们之间自成一派，并没有什么关联，且最大的问题是数据规则是写死的，即开发者制定了所有的规则，用户能修改或定制的部分很少，要么便是自己 import spiders 来重写。</p>
<p>我的设想是统一数据模型。目前为止每个爬虫子模块里面的 item 都是单独定义，很灵活，但当你需要从其他地方导入的时候就不是很优雅，比如会出现大段大段的 <code>spiders.transfermarkt.competition.Item</code> 这样的字段，统一设计数据模型之后，就可以从 models 里面导入。</p>
<p>大概思路是这样，以 competition 作为例子：</p>
<pre><code class="language-python">class Stat:
    def __init__(
        self,
        id: str,
        name: str,
        **fields: typing.Any,
    ) -&gt; None:
        self.id = id
        self.name = name
        self.fields = fields


class Competition(Stat):
    def __init__(
        self,
        id: str,
        name: str,
        country_code: str,
        teams: list[&#x27;Team&#x27;] | None = None,
        matches: list[&#x27;Match&#x27;] | None = None,
    ) -&gt; None:
        super().__init__(id, name)
        self.country_code = country_code
        if teams is None:
            teams = []
        self.teams = teams
        if matches is None:
            matches = []
        self.matches = matches
</code></pre>
<p>每个爬虫子模块的 Competition Item 从父类继承，只要满足父类对于 Competition 定义的字段即可，每个爬虫的特殊字段都塞到 fields 中，至于数据结构，是类还是 dict，又或者其他再讨论。待到从每个爬虫模块收集的数据完毕之后，他们的合并方式，统一在每个类中实现一些 merge 方法，定义了合并之后字段处理的规则，然后再实现 <code>add</code> 方法，每两个数据类结果想要相加，直接调用方法即可，类似于 <code>competition1.add(competition2)</code>，甚至可以实现 <code>__add__</code> 通过运算符操作</p>
<pre><code class="language-python">def add(self, new: &#x27;Competition&#x27;) -&gt; &#x27;Competition&#x27;:
    teams = self._merge_teams(new.teams)
    matches = self._merge_matches(new.matches)
    fields = self.fields | new.fields
    return Competition(
        id=self.id,
        name=self.name,
        country_code=self.country_code,
        teams=teams,
        matches=matches,
        **fields,
    )

def _merge_teams(
    self,
    news: typing.Sequence[&#x27;Team&#x27;],
) -&gt; list[&#x27;Team&#x27;]:
    results: list[&#x27;Team&#x27;] = []
    for query in self.teams:
        selected = process.extractOne(
            query,
            news,
            processor=lambda x: x.name,
        )
        result = selected[0]
        results.append(query.add(result))
    return results

def _merge_matches(
    self,
    news: typing.Sequence[&#x27;Match&#x27;],
) -&gt; list[&#x27;Match&#x27;]:
    ...
</code></pre>
<p>开发者可以任意调整预先要用到的数据类，把他们 add 到一起，比起现版本</p>
<pre><code class="language-python">class Competition:
    def __init__(
        self,
        fotmob: spiders.fotmob.competition.Item,
        fbref: spiders.fbref.competition.Item,
        official: spiders.official.competition.Item,
        transfermarkt: spiders.transfermarkt.competition.Item,
    ) -&gt; None:
        self._fotmob = fotmob
        self._fbref = fbref
        self._official = official
        self._transfermarkt = transfermarkt
</code></pre>
<p>这样的形式优雅很多，然后定义数据规则方法，提供 api。</p>
<p>如果用户不认同这些规则，也可以自己 add，比起现版本也会方便很多。</p>

    </content>
  </entry>
  <entry>
    <title>fusion-stat 能否使用可读性 id</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_id_explore"></link>
    <id>1709042090.1353555</id>
    <updated>2024-02-27T21:54:50Z</updated>
    <published>2024-02-27T21:54:50Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 的 0.0.6 版本更新计划中曾有一项是所有的 id 具有可读性，在我看来是一项能很大提升使用体验的特性，目前的主流数据应用中，都是采用随机或顺序生成的 "id" 类型的 id，比如 Arsenal, fotmob 是 9825, fbref 是 18bb7c10，transfermarkt 是 11。这反映在 url 查询中则是 https://fbref.com/en/squads/18bb7c10/Arsenal-Stats, https://www.transfermarkt.com/fc-arsenal/startseite/verein/11, 虽说添加了名字在 url 中提升可读性，但名字并不是查询的必要条件，真正的查询是通过 id，所以如果能在 id 中实现既有唯一性，又有可读性，就能很好的改善，甚至还可以拼写出 id。
</summary>
    <content type="html">
      <h1>fusion-stat 能否使用可读性 id</h1>
<p>fusion-stat 的 0.0.6 版本更新计划中曾有一项是所有的 id 具有可读性，在我看来是一项能很大提升使用体验的特性，目前的主流数据应用中，都是采用随机或顺序生成的 &quot;id&quot; 类型的 id，比如 Arsenal, fotmob 是 9825, fbref 是 18bb7c10，transfermarkt 是 11。这反映在 url 查询中则是 https://fbref.com/en/squads/18bb7c10/Arsenal-Stats, https://www.transfermarkt.com/fc-arsenal/startseite/verein/11, 虽说添加了名字在 url 中提升可读性，但名字并不是查询的必要条件，真正的查询是通过 id，所以如果能在 id 中实现既有唯一性，又有可读性，就能很好的改善，甚至还可以拼写出 id。</p>
<p>要实现这样的 id，需要探讨两个问题，第一，能不能设计出设计出这样的 id，第二，能不能在 fusion-stat 中顺利实装。</p>
<p>fusion-stat 目前模型以及相互关系是这样的：</p>
<pre><code class="language-python">class Competition:
    teams: list[Team]
    matches: list[Match]


class Team:
    staffs: list[Staff]
    players: list[Player]


class Staff:
    team: Team
    competition: Competition


class Player:
    team: Team
    competition: Competition


class Match:
    competition: Competition
    home: Team
    away: Team
</code></pre>
<p>而要考虑的因素：</p>
<ol>
<li>唯一</li>
<li>可读</li>
<li>尽可能的固定</li>
<li>相互关系中的一致</li>
</ol>
<p>首先是 competition, 赛事的名字不具有唯一性，比如在 fotmob 搜索 Premier League, 会得到 10 个以上的结果，但通常在一个足协单位内，赛事名称是具有唯一性的，比如英格兰的赛事就只有一个 Premier League，使用赛事名字和地区的组合便可用作 competition 的 id，ENG_Premier-League 这样的字符串具有可读性，而赛事名字和赛事地区都是很容易获取的特征，相互关系的一致也能保证。</p>
<p>然后是 team，与 competition 一样，这个世界上可能会有几个 Arsenel，但英格兰内只有一个 Arsenal，所以采用 ENG_Arsenal 这样的字符串作为 id 也是可行的。</p>
<p>接下来是 staff 和 player，名字不具有唯一性，所属俱乐部随着转会经常会变，甚至国籍也有可能更换。出生地是个不错的特征，但通常不能在 team 的数据源内找到，从而无法保证上下文一致，所以能采用的是名字 + 生日，比如 2001-09-05_Bukayo-Saka，同一天生日的人是否具有同名，放在世界范围内可能有很多，但放在球员里面可能就是很小概率的事件了，暂且把它当作可行。</p>
<p>最后是 match, 比赛日期 + 主队 + 客队名字，比如 2023-09-03_Crystal_Palace_vs_Wolverhampton_Wanderers, 和上面 team 讨论的一样，可能会 or, 但是 and 的概率很小，可以当作可行。</p>
<p>下面就是添加到 fusion-stat。country_name 和 country_code 各个数据源使用不一致，在写了 fifacodes 之后可以很好的解决。</p>
<p>后面的工作就没那么好进行下去了，上一级获取下一级的数据可以做到，最主要还是卡在了如何在下一级的数据中获取到上一级一致的特征。比如在 match 中需要获取 competition 和 team 所有的 id 特征，名字是基本特征容易获取到，但国家在目前的数据源内并不能找全，诚然目前可以把 competition 的国家用在 team，但之后添加了洲际比赛，世界级比赛，国家队比赛，这些就没办法使用了。</p>
<p>最终还是放弃了在 0.0.6 版本中更新 id，有可行性，但以目前的数据广度还不能实装，且 player 级的唯一性还需进一步优化，只能在未来不断扩展新的数据源中重点考虑这些特征直到全部可用了。</p>

    </content>
  </entry>
  <entry>
    <title>介绍一下 fifacodes</title>
    <link href="https://tanzhijian.org/posts/fifacodes_intro"></link>
    <id>1705496359.0520616</id>
    <updated>2024-01-17T20:59:19Z</updated>
    <published>2024-01-17T20:59:19Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 的开发过程有很多国家名称和国家代码转换的场景，一些数据源是使用国家名称，另外一些使用国家代码，在使用时需要那么一个工具来统一他们。最开始打算使用 pycountry, 但对于足球数据来说大多是使用国际足联成员国的国家地区来区分，而国际足联国家代码与 ISO 3166-1 三位字母代码是有差异的，比如使用英格兰 ENG 而不是英国 GBR。搜索了一下并没有现成的工具，只能自己写一个。
</summary>
    <content type="html">
      <h1>介绍一下 fifacodes</h1>
<p>fusion-stat 的开发过程有很多国家名称和国家代码转换的场景，一些数据源是使用国家名称，另外一些使用国家代码，在使用时需要那么一个工具来统一他们。最开始打算使用 pycountry, 但对于足球数据来说大多是使用国际足联成员国的国家地区来区分，而国际足联国家代码与 ISO 3166-1 三位字母代码是有差异的，比如使用英格兰 ENG 而不是英国 GBR。搜索了一下并没有现成的工具，只能自己写一个。</p>
<p>首先是数据源，维基百科有现成的表，爬下来即可。但直接使用有个问题是，国家代码是标准的，数据源与数据源的国家名称不一定是标准的，比如我国，大多数数据源是 China，一小部分是 China PR，以至于还需要一个 custom 来添加更多的别名，所幸两百多个国际足联成员国数量并不大，有了基础数据之后，这个 custom 采用手工维护即可。</p>
<p>接下来是方法了，我的设想是，整个国家代码和名称可以抽象成一个 Counties 类，而这个类本质上是一个只读 dict，可以通过 dict 的所有方法索引查询到一个包含代码和名称的 Country 类。</p>
<p>而索引可以并不只限于代码，它的数据特殊性在于，代码是唯一的，名称是唯一的，同时代码与名称之间也是唯一的，所以可以把他们全部添加为索引，既可以用代码也可以用名称，像这样:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.get(&#x27;ENG&#x27;)
Country(code=&#x27;ENG&#x27;, name=&#x27;England&#x27;)
&gt;&gt;&gt; counties[&#x27;England&#x27;]
Country(code=&#x27;ENG&#x27;, name=&#x27;England&#x27;)
</code></pre>
<p>这样使用起来可以不论数据源是使用何种识别方式，都能很好的处理。但由于代码和名称同时在索引内，使用一些迭代方法的时候会出现重复的 value，所以最简单的方法便是使用两个 dict，使用 getitem 的方法时用 key + value 的 dict，使用 iter 时用只有 key 的 dict。</p>
<p>同时还有一个搜索方法，使用 rapidfuzz 来实现 key 的搜索，如果不确定准确的 key，输入一部分也可以获得结果：</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.search(&#x27;ARG&#x27;)
[Country(code=&#x27;ARG&#x27;, name=&#x27;Argentina&#x27;), Country(code=&#x27;AFG&#x27;, name=&#x27;Afghanistan&#x27;), Country(code=&#x27;ALG&#x27;, name=&#x27;Algeria&#x27;)]
&gt;&gt;&gt; counties.search_one(&#x27;Argent&#x27;)
Country(code=&#x27;ARG&#x27;, name=&#x27;Argentina&#x27;)
</code></pre>
<p>一些参数也是可以调节的：</p>
<pre><code class="language-pycon">&gt;&gt;&gt; counties.search(&#x27;Fran&#x27;, limit=2, score_cutoff=70)
[Country(code=&#x27;FRA&#x27;, name=&#x27;France&#x27;), Country(code=&#x27;IRN&#x27;, name=&#x27;Iran&#x27;)]
</code></pre>
<p>基本功能就这些了，已经可以 pip 安装使用。</p>
<p>对于数据的更新，我的设想是默认的基础数据只通过脚本爬取维基百科进行更新，手动维护的 custom 接收 pr 提交，添加的条目代码通常不会有增加，而名称只作为别名添加到索引，返回的 value, Country 仍然使用 default 中的名称，这样比较好规范。</p>

    </content>
  </entry>
  <entry>
    <title>关于在 fusion_stat.models 中使用 shortlist 作为匹配辅助的探讨</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_shortlist"></link>
    <id>1704821742.058141</id>
    <updated>2024-01-10T01:35:42Z</updated>
    <published>2024-01-10T01:35:42Z</published>
    <author><name>tanzhijian</name></author>
    <summary>fusion-stat 有一个一直让我不安的地方，就是在使用 rapidfuzz.process.extractOne 匹配时返回唯一结果的正确性，我并不确定他在扩展越来越多的数据源后能不能继续保持良好的运转，所以一直在探索一些方法解决。而今晚想到一个暂且看上去还不错，但也不是很好的，先上代码吧
</summary>
    <content type="html">
      <h1>关于在 fusion_stat.models 中使用 shortlist 作为匹配辅助的探讨</h1>
<p>fusion-stat 有一个一直让我不安的地方，就是在使用 rapidfuzz.process.extractOne 匹配时返回唯一结果的正确性，我并不确定他在扩展越来越多的数据源后能不能继续保持良好的运转，所以一直在探索一些方法解决。而今晚想到一个暂且看上去还不错，但也不是很好的，先上代码吧</p>
<pre><code class="language-python">import typing
import warnings
from abc import ABC

from rapidfuzz import fuzz, process

_S1 = typing.TypeVar(&#x27;_S1&#x27;)
_S2 = typing.TypeVar(&#x27;_S2&#x27;)


MINIMUM_SIMILARITY = 50
SIMILARITY_DIFFERENCE = 5


class BaseModel(ABC):
    def __init__(self, show_warning: bool = True) -&gt; None:
        self.show_warning = show_warning
        self._shortlist: list[typing.Any] = []

    @property
    def shortlist(self) -&gt; list[typing.Any]:
        return self._shortlist

    def extract(
        self,
        query: _S1,
        choices: list[_S2],
        scorer: typing.Callable[..., int | float] = fuzz.WRatio,
        processor: typing.Callable[..., typing.Sequence[typing.Hashable]]
        | None = None,
        score_cutoff: int | float | None = None,
    ) -&gt; _S2:
        results = process.extract(
            query,
            choices,
            scorer=scorer,
            processor=processor,
            score_cutoff=score_cutoff,
        )

        first = results[0]
        second = results[1] if len(results) &gt; 1 else None
        if first[1] &lt; MINIMUM_SIMILARITY:
            if self.show_warning:
                warnings.warn(
                    (
                        &#x27;The result similarity is less than 50%, &#x27;
                        &#x27;please check the shortlist.&#x27;
                    ),
                    SimilarityWarnings,
                )
            self._shortlist.append((query, results))
        elif (
            second is not None
            and abs(first[1] - second[1]) &lt; SIMILARITY_DIFFERENCE
        ):
            if self.show_warning:
                warnings.warn(
                    (
                        &#x27;There are results that are too similar, &#x27;
                        &#x27;please check the shortlist.&#x27;
                    ),
                    SimilarityWarnings,
                )
            self._shortlist.append((query, results))

        return results[0][0]


class SimilarityWarnings(Warning):
    pass
</code></pre>
<p>我的大致思路是每个 model 都继承 BaseModel 获得 shortlist 和 extract，extract 是对 rapidfuzz.process.extract 的扩写，基本就是通过 rapidfuzz.process.extract 先获得初步结果 results，然后再进行一系列的判定：</p>
<ul>
<li>如果最接近的结果小于 50% 则提示</li>
<li>如果最接近的两个结果过于相似也提示</li>
<li>并把所有的结果放到候选列表 shortlist</li>
<li>最终仍然会返回最接近的结果</li>
</ul>
<p>在使用 rapidfuzz.process.extractOne 的地方替换成使用 self.extract。当然了上面的代码只是一个初步的草稿，并没有考虑太多的条件，数值胡乱设一些，shortlist 也没有封装，但大致思路是，在程序一些不能很好判定的时候，把检查核对交给使用者</p>
<p>但不好的地方在于，fusion-stat 面对的足球数据源通常只有两类：每个数据源都能够一一对应的数据类型，比如赛事，参赛球队，比赛，历史数据；每个数据源不能一一对应上的数据类型，比如球员名单，一些数据源会包含二队，青年队，位置参数，每个数据源对于位置的理解是有差别；而 extractOne 基本是在匹配后一类时会出错，所以 self.extract 并不能成为一个通用方法，而是专用方法</p>
<p>另一个顾虑是，在使用 extractOne 匹配不能一一对应的数据时目前是设置了 score_cutoff 参数一刀切，最小匹配策略，而如果想在这上面优化，默认返回的匹配结果将会是一个很大的问题，因为没有达到标准，如果要返回大概率将会是一个错误的结果，而同时还需要把 shorlist 交给使用者判定，如果使用者没有注意到 shortlist 呢，或者只是想把它跑在一个自动化程序里面并不想每天去观察改动呢</p>
<p>所以原本打算在 0.0.5 使用上这个功能，但又暂时不考虑了</p>

    </content>
  </entry>
  <entry>
    <title>一些读取环境变量的探讨</title>
    <link href="https://tanzhijian.org/posts/explore_env"></link>
    <id>1704024002.7686512</id>
    <updated>2023-12-31T20:00:02Z</updated>
    <published>2023-12-31T20:00:02Z</published>
    <author><name>tanzhijian</name></author>
    <summary>我最早使用，到现在也一直在用的包了，基本覆盖了日常使用的需求，简单，可读性也很好
</summary>
    <content type="html">
      <h1>一些读取环境变量的探讨</h1>
<h2>python-decouple</h2>
<p>我最早使用，到现在也一直在用的包了，基本覆盖了日常使用的需求，简单，可读性也很好</p>
<pre><code class="language-python">def test_decoupe_config() -&gt; None:
    foobar = config(&#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    assert config(&#x27;NUMBER&#x27;) == &#x27;1&#x27;
    assert config(&#x27;NUMBER&#x27;, cast=int) == 1

    with pytest.raises(UndefinedValueError):
        assert not config(&#x27;FOO&#x27;)

    foo = config(&#x27;FOO&#x27;, default=None)
    assert foo is None
</code></pre>
<p>但是它在一些静态工具里面会丢失类型提示，比如 pyright <code>foobar = config(&#x27;FOOBAR&#x27;)</code> 会被推断为类型 <code>bool | Unknown</code>，以至于每次要正确设置类型的时候需要 <code>foobar: str | None = config(&#x27;FOOBAR&#x27;)</code></p>
<p>它的主类 <code>def __call__(self, *args, **kwargs):</code>，也不能支持参数的补全提示</p>
<h2>python-dotenv</h2>
<p>推荐用法之一是统一调用函数 <code>load_dotenv()</code>，它的具体细节是这样：</p>
<pre><code class="language-python">def set_as_environment_variables(self) -&gt; bool:
    &quot;&quot;&quot;
    Load the current dotenv as system environment variable.
    &quot;&quot;&quot;
    if not self.dict():
        return False

    for k, v in self.dict().items():
        if k in os.environ and not self.override:
            continue
        if v is not None:
            os.environ[k] = v

    return True
</code></pre>
<p>把读取到的 .env 通过 <code>os.environ[k] = v</code> 写到环境变量，使用时 <code>os.getenv()</code> 读取即可，好处是使用逻辑比较统一，但我个人并不喜欢这样用，因为会污染到环境变量</p>
<p>不过它提供一个用来专门读取 .env 的函数 dotenv_values</p>
<pre><code class="language-python">def test_dotenv_values() -&gt; None:
    dotenv = dotenv_values(&#x27;.env&#x27;)
    foobar = dotenv[&#x27;FOOBAR&#x27;]
    assert foobar == &#x27;foobar&#x27;

    assert dotenv[&#x27;NUMBER&#x27;] == &#x27;1&#x27;

    with pytest.raises(KeyError):
        assert not dotenv[&#x27;FOO&#x27;]

    foo = dotenv.get(&#x27;FOO&#x27;)
    assert foo is None
</code></pre>
<p>默认是读取 <code>.env</code>，也可以传入其他文件名，返回值是一个 dict，使用就和操作 dict 一样，可以通过 <code>.get</code> 返回 <code>str | None</code>，也可以直接抛出 <code>KeyError</code>，很方便。还可以通过解包的形式读取多个配置以及环境变量</p>
<pre><code class="language-python">config = {
    **dotenv_values(),
    **dotenv_values(&#x27;.env.test&#x27;),
    **os.environ,
}
</code></pre>
<p>缺点是纯手动，也没有自带的类型转换，其实关系不大，无论是简单的还是复杂的转换无非就是自己多写这行代码还是通过参数传入逻辑的区别。也有单个读取 <code>get_key()</code></p>
<pre><code class="language-python">def test_dotenv_get_key() -&gt; None:
    foobar = get_key(&#x27;.env&#x27;, &#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    foo = get_key(&#x27;.env&#x27;, &#x27;FOO&#x27;)
    assert foo is None
</code></pre>
<pre><code class="language-python">def get(key: str) -&gt; str | None:
    if (value := get_key(&#x27;.env&#x27;, key)) is not None:
        return value
    return os.getenv(key)
</code></pre>
<p>缺点还是纯手动。但它依然是使用者最多的包，很适合用来在此基础上开发更多的功能</p>
<h2>pydantic-settings</h2>
<p>pydantic-settings 便是使用了 python-dotenv 支持 .env 读取</p>
<pre><code class="language-python">class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=&#x27;.env&#x27;,
        env_file_encoding=&#x27;utf-8&#x27;,
    )

    FOOBAR: str | None = None
    NUMBER: int | None = None


def test_pydantic_settings() -&gt; None:
    settings = Settings()
    assert settings.FOOBAR == &#x27;foobar&#x27;
    assert settings.NUMBER == 1
</code></pre>
<p>通过 pydantic 优秀的验证和转换，可以实现很好的类型转换。如果项目中使用了 pydantic 可以优先使用它</p>
<h2>starlette.config</h2>
<p>starlette.config 在我看来是 python-decouple 最完美的替代品了，而且它和 python-decouple 也算是渊源颇深。用法基本一致</p>
<pre><code class="language-python">def test_starlette_config() -&gt; None:
    config = Config(&#x27;.env&#x27;)
    foobar = config(&#x27;FOOBAR&#x27;)
    assert foobar == &#x27;foobar&#x27;

    assert config(&#x27;NUMBER&#x27;) == &#x27;1&#x27;
    assert config(&#x27;NUMBER&#x27;, cast=int) == 1
    assert config(&#x27;NUMBER&#x27;, cast=bool) is True

    with pytest.raises(KeyError):
        assert not config(&#x27;FOO&#x27;)

    foo = config(&#x27;FOO&#x27;, default=None)
    assert foo is None
</code></pre>
<p>类型提示，参数补全的问题被解决掉了，同时它还有一个实现的很有意思的 Secret 类用来读取敏感数据</p>
<pre><code class="language-python">class Secret:
    &quot;&quot;&quot;
    Holds a string value that should not be revealed in tracebacks etc.
    You should cast the value to `str` at the point it is required.
    &quot;&quot;&quot;

    def __init__(self, value: str):
        self._value = value

    def __repr__(self) -&gt; str:
        class_name = self.__class__.__name__
        return f&quot;{class_name}(&#x27;**********&#x27;)&quot;

    def __str__(self) -&gt; str:
        return self._value

    def __bool__(self) -&gt; bool:
        return bool(self._value)
</code></pre>
<pre><code class="language-python">def test_starlette_config_secret() -&gt; None:
    config = Config(&#x27;.env&#x27;)
    secret = config(&#x27;FOOBAR&#x27;, cast=Secret)
    assert repr(secret) == &quot;Secret(&#x27;**********&#x27;)&quot;
    assert str(secret) == &#x27;foobar&#x27;
</code></pre>
<p>没有用加密手段却规避了在调试时的信息泄露。但它的不方便之处在于，不可能为了只使用而安装整个 Starlette。于是大多数时候都是用 python-dotenv 自己写一个读取的类</p>

    </content>
  </entry>
  <entry>
    <title>介绍一下 fusion-stat</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_intro"></link>
    <id>1703233933.8477497</id>
    <updated>2023-12-22T16:32:13Z</updated>
    <published>2023-12-22T16:32:13Z</published>
    <author><name>tanzhijian</name></author>
    <summary>更新：已经更新 API
</summary>
    <content type="html">
      <h1>介绍一下 fusion-stat</h1>
<p>更新：已经更新 API</p>
<hr />
<p>最初只是想给 score-simulator 写一个获取数据的脚本，但写着写着应该可以写成一个工具，可以方便获取网络上免费公开足球数据的爬虫工具，到目前为止可以正常给 score-simulator 提供数据了，于是发布了一个版本到 pip 方便自己使用。</p>
<p>他的特点是同时从不同的数据源获取然后组合在一起。因为这确实是获取足球数据一个很麻烦的事情，从一个数据源获取一些数据，从另一个数据源获取另一些数据，他们大多数基础数据是相同的，只有一些不同的特色数据，而 fusion-stat 便是在获取数据时就把它们最大程度的拼接在一起，通过一次调用就可以获得一份尽可能全面的数据。</p>
<pre><code class="language-python">competitions = Competitions()
fusion = await competitions.gather()
</code></pre>
<p>使用 httpx 完成 downloader 类似的功能，所以提供了可以在初始化时传入 httpx.AsyncClient 的一些参数，比如 <code>competitions = Competitions(proxies=PROXIES)</code>，由于是通过 <code>**kwargs</code>，缺乏参数类型补全提示，后续还会改进。每个类都会初始化一个 AsyncClient 作为 client，如果是大量爬取势必会增加开销，所以还可以提前创建好一个 client 每次传入使用:</p>
<pre><code class="language-python">async with httpx.AsyncClient(proxies=PROXIES) as client:
    competition = Competition(
        fotmob_id=&quot;47&quot;, 
        fbref_id=&quot;9&quot;, 
        fbref_path_name=&quot;Premier-League&quot;,
        official_name=&quot;Premier League&quot;,
        season=2022,
        client=client,
    )
</code></pre>
<p>关于参数，最初的设想是只需要传入一个具有唯一特征同时还有可读性的参数，比如：</p>
<pre><code class="language-python">member = Member(&quot;Bukayo Saka&quot;)
</code></pre>
<p>很漂亮但显然不具有可行性。且不说唯一性，单是如何通过一行字符串到最终完成不同数据源的请求 url 都很困难，如果只是赛事，或者球队，即使规模扩大到很大，几百个赛事，几千支球队，可以通过缓存一份数据来提供查询，但更多的球员名，随时在增加的比赛，就不大可能缓存下来了，这无异于还得提供一个数据库。</p>
<p>所以目前采用这样一种方法，不是很方便手动输入，但可以通过上一级获取到的 index 来使用：</p>
<pre><code class="language-python">fusion = await team.gather()
saka = fusion.members_index()[-2]
saka
</code></pre>
<pre><code>{&#x27;fotmob_id&#x27;: &#x27;961995&#x27;,
 &#x27;fbref_id&#x27;: &#x27;bc7dc64d&#x27;,
 &#x27;fbref_path_name&#x27;: &#x27;Bukayo-Saka&#x27;}
</code></pre>
<pre><code class="language-python">member = Member(**saka)
fusion = await member.gather()
</code></pre>
<p>如果需要长期使用，在第一次获取时本地缓存一份 index，就可以极大的方便后续使用了。</p>
<p>目前数据源只写了很小的一部分，只满足了 score-simulator 的需求，之后会继续完善。如果想要添加更多的数据，或者更多的来源，在 spiders 里面新建一个模块继承 Spider 类，然后实现 request 和 parse:</p>
<pre><code class="language-python">class Futbol(Spider):

    @property
    def request(self) -&gt; httpx.Request:
        ...

    def parse(self, response: httpx.Response) -&gt; Any:
        ...
</code></pre>
<p>可以参考其他的爬虫写法。之后在对应的 fusion 添加进去即可，欢迎提交 pr。</p>
<p>总体来说，目前处于一个能用但不好用的地步。需要改进的地方太多，比如最后的数据类 Fusion，虽然都是 fusion，但方法大相径庭，需要一个更好的方案；models 里面的各种杂乱的数据模型类看起来很糟糕；也没有文档，想要正常使用得看源代码。慢慢写了，最初设计的时候并没有规划太多，大部分都是写一步看一步。</p>

    </content>
  </entry>
  <entry>
    <title>关于在 fusion-stat 中使用 rapidfuzz 匹配名字</title>
    <link href="https://tanzhijian.org/posts/fusion_stat_and_rapidfuzz"></link>
    <id>1697038565.0</id>
    <updated>2023-10-11T23:36:05Z</updated>
    <published>2023-10-11T23:36:05Z</published>
    <author><name>tanzhijian</name></author>
    <summary>最近一有时间就在写一个叫 [fusion-stat](https://github.com/tanzhijian/fusion-stat) 的开源项目，这是我一直想做却一直搁置直到最近才下决心开坑的东西，这个世界上有很多免费公开的足球数据源，每个数据源有相同的数据也有特有的数据，很多时候这些数据都是分散的，fusion-stat 就是想做这么一件事，把各类数据源的不同数据寻找到相关的特征从而把它们匹配连接起来，使得一次调用便可以获取到多个来源的数据，譬如
</summary>
    <content type="html">
      <h1>关于在 fusion-stat 中使用 rapidfuzz 匹配名字</h1>
<p>最近一有时间就在写一个叫 <a href="https://github.com/tanzhijian/fusion-stat">fusion-stat</a> 的开源项目，这是我一直想做却一直搁置直到最近才下决心开坑的东西，这个世界上有很多免费公开的足球数据源，每个数据源有相同的数据也有特有的数据，很多时候这些数据都是分散的，fusion-stat 就是想做这么一件事，把各类数据源的不同数据寻找到相关的特征从而把它们匹配连接起来，使得一次调用便可以获取到多个来源的数据，譬如</p>
<pre><code class="language-python">team = Team(&quot;Arsenal&quot;)
team.get()
team.info
team.players
</code></pre>
<p>输出的数据可以从各个数据来源中填充。</p>
<p>从各个数据源获取到需要的数据并不难，难在如何把它们准确的拼接起来，并不是每个数据源的名称都是一样的，比如 &quot;UEFA Champions League&quot; 与 &quot;Champions League&quot;; &quot;Man United&quot; 与 &quot;Manchester United&quot;, &quot;Manchester Utd&quot;; &quot;Gabriel Dos Santos&quot; 与 &quot;Gabriel&quot;，直观能想到的就是自然语言处理，实体消歧义，实体链接，但用一个机器学习的模型对于这样一个项目太重了，且需要手动来标注校对很多数据，以我一个人的业余时间并不能做到，如果是本地项目可以使用数据库，也不是什么难的事情，对于足球这样的小数据你甚至可以手动拼接很可能效率高于写代码。。。但。。。所以只好想其他的方法，那就先用计算相似度了。</p>
<p>足球数据有一些特有的特征，比如球队，每个赛事内的球队名很难有相似的，且虽然是不同的数据源，但只要是一样的赛事一样的赛季，就一定可以一一对应上的，比如</p>
<pre><code class="language-python">for t1 in teams_1:
    t2 = process.extractOne(t1, teams_2)
    print(f&quot;{t1} is {t2[0]}&quot;)
</code></pre>
<pre><code>Manchester City is Man City
Tottenham Hotspur is Tottenham
Liverpool is Liverpool
West Ham United is West Ham
Arsenal is Arsenal
Brighton &amp; Hove Albion is Brighton
Crystal Palace is Crystal Palace
Brentford is Brentford
Nottingham Forest is Nottm Forest
Aston Villa is Aston Villa
Manchester United is Man United
Chelsea is Chelsea
Fulham is Fulham
Newcastle United is Newcastle
Wolverhampton Wanderers is Wolves
AFC Bournemouth is Bournemouth
Sheffield United is Man United
Everton is Everton
Luton Town is Luton
Burnley is Burnley
</code></pre>
<p>效果很好，但其他的数据，联赛，不同国家之间的联赛名可能会极其相似，比如 意甲联赛叫 Serie A，巴西的联赛也叫 Série A，但加上一些其他特征，比如国家或者地区，每个国家的各级联赛名字基本很难相似；球员名也是，每个球队不可避免的有些球员名之间极为相似，比如阿森纳的 Gabriel，他在 FotMob 的名字是 Gabriel，在 FBref 的名字是 Gabriel Dos Santos，如果只使用名字来做匹配拼接，他俩的相似度不如 Gabriel Jesus，所以需要加上其他的特征，比如目前在 fusion-stat 中使用到的国家和位置</p>
<pre><code class="language-python">def fuzzy_similarity_mean(
    l1: list[str], l2: list[str], **kwargs: typing.Any
) -&gt; float:
    scores = [fuzz.ratio(s1, s2) for s1, s2 in zip(l1, l2)]
    return sum(scores) / len(scores)


process.extractOne(
    [&quot;Gabriel&quot;, &quot;BRA&quot;, &quot;DF&quot;], 
    [
        [&quot;Gabriel Dos Santos&quot;, &quot;BRA&quot;, &quot;DF&quot;],
        [&quot;Gabriel Jesus&quot;, &quot;BRA&quot;, &quot;FW&quot;],
        [&quot;Gabriel Martinelli&quot;, &quot;BRA&quot;, &quot;FW&quot;],
    ],
    scorer=fuzzy_similarity_mean,
)
</code></pre>
<pre><code>([&#x27;Gabriel Dos Santos&#x27;, &#x27;BRA&#x27;, &#x27;DF&#x27;], 85.33333333333333, 0)
</code></pre>
<p>对球员名和赛事并不是每个数据源都是相同的数量，上面提到的 FotMob 和 FBref，一线队名单一个是 25 一个 23，所以需要加上一个预设分数，如果相似度分数低于某个值则判定为两个人不予匹配，我大概设了一个值目前测试下来没什么问题，但也只是暂时，你不能避免万一某一支球队里面有两兄弟，他们名字只差一个字母，出生年月日，国籍，身高，位置都一样。。。需要在日后开发中再改进了。</p>
<p>至少对于目前开放的六个联赛的数据是没问题的。</p>

    </content>
  </entry>
  
</feed>