<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tanzhijian.org</title>
  <id>https://tanzhijian.org/atom.xml</id>
  <updated>2023-06-14T21:32:19Z</updated>
  <link href="tanzhijian.org"/>
  <link href="https://tanzhijian.org/atom.xml" rel="self"/>
  <generator>?</generator>
  <entry>
    <title>《挪威的森林》读书笔记</title>
    <link href="https://tanzhijian.org/posts/norwegian_wood"></link>
    <id>1686749539.7737155</id>
    <updated>2023-06-14T21:32:19Z</updated>
    <published>2023-06-14T21:32:19Z</published>
    <author><name>tanzhijian</name></author>
    <summary>即使过了很多年，我仍然抑制不住对这本书的偏爱。
</summary>
    <content type="html">
      <h1>《挪威的森林》读书笔记</h1>
<p>即使过了很多年，我仍然抑制不住对这本书的偏爱。</p>
<h2>1.</h2>
<p>这是一个关于青春的故事。轻松，幽默，直白。十八岁的渡边来到东京上大学，住在集中式宿舍，室友是生活习惯规矩而普通的“敢死队”，准时规律起床做操；没有突出的个性，房间里贴运河的贴画，对文学不甚了了。让我想起以前读书那会儿班上农村的孩子，老实上学规矩生活，却被城里见过世面富有个性的孩子当作“怪咖”的笑料。对于理想什么的也没多大见解，只认准“绘地图，毕业去国土地理院”。</p>
<p>相对来说，随后出现的永泽，则像是以“敢死队”的反面存在的人物。譬如与渡边的对话里表达出的对于理想的见解：“人生中无需那种东西，需要的不是理想，而是行为规范！”，坦诚的痛快。毕业后进入外务省“施展自己的一番拳脚，想看看自己在这臃肿庞大的官僚机构中能爬到什么地步”，对自己有清晰的认识。读过的书“我辈较之他真可谓望尘莫及”。对于事物均有着强烈的个人见解，气质非凡。渡边与之在一起也实则有趣，讨论《了不起的盖茨比》，喝酒，与年轻女性约会，展现年轻人生活应有的部分。在描写中也少见的以相对激进直白的方式。罢课期间的一段描述：</p>
<blockquote>
<p>于是我走到他们跟前，问他们何以前来教室而不继续罢课，他们没有回答，也没法回答。他们害怕因缺课过多而拿不到学分。此等人物居然也高喊什么肢解大学，想来令人喷饭。如此卑劣小人，唯有见风使舵投敌变节之能事。</p>
<p>我说木月，这帮家伙一个不少的拿得大学学分，跨出校门，将不遗余力地构筑一个同样卑劣的社会。</p>
</blockquote>
<p>较之小部分的激进，通常的村上则是习惯布局隐喻。结识绿子以后，交谈中一些轻松幽默的段子：</p>
<blockquote>
<p>“这里烧着了也不跑？”</p>
<p>“嗯，死了就死了呗！”</p>
<p>“好，我明白，奉陪就是，陪你。”</p>
<p>“和我一块死？”</p>
<p>“难说，一旦势头不妙我可得逃走。要死你一个人死好了”</p>
<p>“冷酷。”</p>
<p>“只讨你一顿午饭，怎么能连命都一块搭进去呢？晚饭也招待的话另当别论。”</p>
<p>“你这人！算啦算啦。反正现在这儿看一会吧。我来唱歌给你听。”</p>
<p>“唱歌？”</p>
</blockquote>
<p>于是面对失火的场景，渡边一边喝啤酒，一边欣赏绿子弹唱。直白表达宣泄，对周遭事物不屑一顾，这是属于年轻人的专利，不至于被扣上什么“冷漠”“没有公德心”的帽子。</p>
<p>渡边几乎又是村上笔下那种一个模子刻出来的主角：三十七岁，孤单，话好像不多，并没表现出什么特别才能和特别个性；年轻时候喜好的读书和听音乐，无非是大众都能脱口而出的爱好。我曾经在一篇豆瓣影评里读到这样一段评论日本作家的话：“肆意描写着性，谋杀，毒品以及病态的心。”，《挪威的森林》开篇正是以渡边自我解读内心的情感开始的。渡边的内心世界，敏感而细致，同时又充满巨大的疑惑和否定。</p>
<p>对于“敢死队”，渡边怀着戏虐的心态，作为笑料的谈资；在“敢死队”离开后，却又不时怀念起，甚至充满羡慕和感激。</p>
<p>对于永泽，渡边算是真正了解，同时也被真正了解。对于永泽性格的一部分，诚实，潇洒，一些独特的见解，渡边是抱欣赏态度。但同时永泽对于女性的态度，更确切来说对初美的态度，因为他的傲慢，对人生清醒的认识，使得渡边在与初美的交谈中几乎明确的说出：“与永泽是没有未来的”。最后因为初美的自杀，使得渡边对于永泽彻底爆发：“把告知初美死讯的信撕得粉碎，此后再未给他写过信。”</p>
<p>对于初美，是起初连渡边都不明白的情感，直到书中所说的“十二三年以后”，来到新墨西哥州的圣菲城：</p>
<blockquote>
<p>傍晚，我走近附近一家意大利比萨饼店，一边喝啤酒嚼比萨饼，一边眺望美丽的夕阳。天地间的一切全都红彤彤一片。我的手，盘子，桌子，凡是目力所及的东西，无不被染成了红色，而且红得非常鲜艳，俨然被特殊的果汁从上方直淋下来似的。就在这种气势夺人的暮色当中，我猛然想起了初美，并且这时才领悟她给我带来的心灵震撼究竟是什么东西——它类似一种少年时代的憧憬，一种从来不曾实现而且永远不可能实现的憧憬。</p>
</blockquote>
<p>书中对于初美的描写可谓是完美：高雅，善良，热情，得体，理智。永泽也曾感叹：“配我太可惜了。”而在渡边领悟到此为何物时，“这种直欲燃烧般的天真烂漫的憧憬，我在很早以前就已遗忘在什么地方了，甚至很长时间里我连它曾在我心中存在过都记不起来了。”“当我恍然大悟时，一时悲怆之极，几欲涕零。”书中的这一段文字极为华美，读到这一段时心中不由泛滥出多种别样的心绪：在年少时也心醉于周围看起来如此美好的女性，常不能自拔，我清楚的知道这与爱情什么的无关，但没办法解析的再明白，直到这一刻才恍然大悟了，这什么都不是，只与年轻有关。</p>
<h2>2.</h2>
<p>前面提到了整本书以渡边解读内心的情感开始，贯穿主线的，正是渡边内心不断发展的两条情感主线：一条渴望正常生活，同时也在过着正常生活；另一条陷入一团泥潭，一团因木月之死直子带来的心结的泥潭。</p>
<p>这好像也映射了渡边内心两种矛盾性格的部分：一部分封闭了自我，只在属于木月，直子的圈子里打转；另一部分却好像已经全然无事的接受了新的生活，上课打工结交新朋友。在书开头的部分木月死后渡边住进宿舍时有一句话：“死并非生的对立面，而作为生的一部分永存”。几乎已经说出了本书的主线：木月直子渡边的牵绊，不可磨灭的存在于渡边今后的生活中。</p>
<p>渡边第一次去“阿美寮”，剧情上是探望正在与心理做抗争的直子，但我解读成渡边在对自己内心的治疗：与绿子的接触，与永泽在新宿街头游荡，使得渡边的内心一些摇摆的躁动。他应该呆在自己封闭的内心，可现实的诱惑让他无法拒绝。书中则通过了石田玲子——既是治愈直子，同时也治愈着渡边——来说出渡边寻求的答案：“因为那是你的人生，应该由你决定。我要说的，只是希望你不要用不自然的方式磨损自己。懂吗？那是最不得偿失的。”</p>
<p>之后永泽对渡边的一番解剖挺有意思：</p>
<blockquote>
<p>他和我一样，在本质上都是只对自己感兴趣的人，只不过在傲慢和不傲慢上有所差别，自己想什么，自己感受什么，自己如何行动——除此之外对别的没有兴趣，所以才能把自己同别人分开来考虑。我喜欢渡边也无非喜欢他这一点。只是他这小子还没有清楚的认识这点，以致感到迷惘和痛苦。</p>
</blockquote>
<p>准确无误，实际上渡边的所有行动都已经倾向了正常的生活，只是他自己还未认识到。</p>
<p>当渡边读到了玲子的信，得知直子病情已经恶化时，内心已经明晰了：“木月！我和你不同，我决心活下去。”“我已不是十几岁的少年，我已感到自己肩上的责任。”虽然还在等待直子的康复，但不可回避的，两条内心已经合并，走向了结局。</p>
<h2>3.</h2>
<p>小林绿子和石田玲子。这两位无疑是《挪威的森林》里的“特殊人物”，唯二享有“全名”的待遇。</p>
<p>绿子是渡边正常生活的重要组成部分，活力，善解人意，别具一格。与渡边的心理很多的时候都很是合拍，譬如孤独。绿子讨厌自己父亲给选择的高中女校，却从不曾迟到和缺课；被父亲生病折磨的不胜其烦，却还是尽心的照顾。不掩饰自己的好恶，在大骂了一通税务员后抛出了一句耐人寻味的：“我才不信什么革命哩！我只信爱情。”总有那么些稀奇古怪目瞪口呆的脑补，给人感觉却是真实。</p>
<p>这样的性格仿佛才是渡边在找寻的。</p>
<p>石田玲子在整本书中担任了“治愈”的角色。渡边去到“阿美寮”；随后与渡边的几番通信；在直子死后来到渡边的出租屋弹唱《挪威的森林》；化解了渡边迟迟无法解开的“好凄凉的葬礼”；最后还以以直子的方式收了在之前埋下身穿直子衣服的伏笔。</p>
<p>我向来有一种看法，村上塑造的角色，有些不能以”角色“这样的角度来定义。他们更多时候像是扮演一面镜子，为了主角审视混乱不堪的自己而存在。譬如《海边的卡夫卡》里的大岛，冷静的不像话，随时在通过聊天的方式，让田村卡夫卡审视真实的自己。玲子的存在大概也是如此，在用所有的办法让渡边了解了真实的自己。</p>
<h2>4.</h2>
<p>关于活下去。</p>
<p>故事的最后，渡边送别了玲子，打电话给绿子，一切从头开始。</p>
<p>绿子问渡边“你现在在哪里？”，小说到这里结束，渡边早已不再困惑，引用之前永泽的话说：“只是他这小子还没有清楚的认识这点。”</p>
<p>而答案其实在书的中间一段，渡边第一次去“阿美寮”时与直子的一次对话中就已清楚给出：“你太悲观了，在黑夜，噩梦，私人的力量面前太胆小了。你必须做的是忘记这些。”这便是渡边早已明白，却一直无法认清的。</p>

    </content>
  </entry>
  <entry>
    <title>score-simulator 的一些想法</title>
    <link href="https://tanzhijian.org/posts/score_simulator"></link>
    <id>1686477588.3136425</id>
    <updated>2023-06-11T17:59:48Z</updated>
    <published>2023-06-11T17:59:48Z</published>
    <author><name>tanzhijian</name></author>
    <summary>最近在利用业余时间入门 2023 年前端的新姿势，前两天无聊趁着欧冠决赛前夜，用目前所学到的写了一个前端的比分模拟器 [score-simulator](https://score-simulator.tanzhijian.org/)，小规模发给了一些朋友 roll，反响居然不错，都 roll 得蛮开心的。所以想说一下模拟比赛的原理，以及之后会完善的一些思路。
</summary>
    <content type="html">
      <h1>score-simulator 的一些想法</h1>
<p>最近在利用业余时间入门 2023 年前端的新姿势，前两天无聊趁着欧冠决赛前夜，用目前所学到的写了一个前端的比分模拟器 <a href="https://score-simulator.tanzhijian.org/">score-simulator</a>，小规模发给了一些朋友 roll，反响居然不错，都 roll 得蛮开心的。所以想说一下模拟比赛的原理，以及之后会完善的一些思路。</p>
<p>score-simulator 的模型设想是通过简化的方式来模拟一场比赛，在比赛中随机出现进球，但不能是完全随机，需要参考现实中的表现参数。所以首先是每分钟的射门事件，主队 + 客队本赛季的平均每 90 分钟射门次数，得到比赛每分钟射门的概率。</p>
<p>接下来如果产生了射门，那么是谁的。这里使用了一方射门数 / 射门总数得出主客队射门占比。</p>
<p>但由于两队实力的不均衡，使用了队伍的排名 <a href="http://www.clubelo.com/">clubelo</a> 作为权重，强的队伍 = 1, 弱的队伍 /= 强的队伍。</p>
<p>再使用双方赛季总预期进球 / 赛季总射门次数，得到双方的每次射门的平均预期进球 xG/Sh，来确定本次射门是否进球。</p>
<p>到这里模拟了每分钟的事件，运行 90 次得到一场比赛的结果。</p>
<pre><code class="language-python">def whoscored(home_goal: int = 0, away_goal: int = 0) -&gt; tuple[int, int]:
    attempt = rnd.rand(1, 1)
    if attempt &lt; shot_prob_per_minute:
        who = rnd.rand(1, 1)
        if who &lt; shot_percentage:
            shot = rnd.rand(1, 1)
            if shot &lt; home_xg_per_shot:
                home_goal += 1
        else:
            shot = rnd.rand(1, 1)
            if shot &lt; away_xg_per_shot:
                away_goal += 1
    return home_goal, away_goal


def play_game():
    for _ in range(90):
        pass
</code></pre>
<p>之后会完善一下模拟比赛的模型，比如加上一些正态分布，使得比分结果更为合理，比如一些考虑到防守质量的参数。</p>
<p>还会获取现实的赛程表和数据，也能自己编辑队伍，使得在更多的比赛开场前都能玩一玩。</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季射门探索 02: xG 特征</title>
    <link href="https://tanzhijian.org/posts/invincible_06"></link>
    <id>1684569035.9120426</id>
    <updated>2023-05-20T15:50:35Z</updated>
    <published>2023-05-20T15:50:35Z</published>
    <author><name>tanzhijian</name></author>
    <summary>b 站刷到了一个 StatsBomb 的 xG 教学视频 [https://www.bilibili.com/video/BV13V4y1k77j](https://www.bilibili.com/video/BV13V4y1k77j), 更详细介绍了他们使用的 xG 特征，其视频后段也列了出来，重要的特征还标注了星标：
</summary>
    <content type="html">
      <h1>阿森纳不败赛季射门探索 02: xG 特征</h1>
<p>b 站刷到了一个 StatsBomb 的 xG 教学视频 <a href="https://www.bilibili.com/video/BV13V4y1k77j">https://www.bilibili.com/video/BV13V4y1k77j</a>, 更详细介绍了他们使用的 xG 特征，其视频后段也列了出来，重要的特征还标注了星标：</p>
<ul>
<li><strong>射门距离</strong></li>
<li><strong>射门角度</strong></li>
<li>射门身体部位</li>
<li><strong>射门是否来自定位球</strong></li>
<li><strong>射门是否来自传中，什么类型的传中</strong></li>
<li>射门是否来自直塞球</li>
<li>射门是否来自完成盘带后</li>
<li><strong>射门时接近的防守队员</strong></li>
<li>防守区域或者密度</li>
<li><strong>射门与球门形成的三角形内球员人数</strong></li>
<li>守门员的位置</li>
<li>射门时球的高度</li>
</ul>
<p>比起上一篇文章从他们的推特视频推断出的特征，多了一些射门前动作的判定。定位球需要单独的模型训练这个自不消说；射门前的动作，通过推进调整后的射门，球在脚下理论上射门难度是最低的；接到直塞球和完成盘带后球可能不会处在一个很舒服的位置；接到传中的射门最难，且球的高度越高越难以把握。</p>
<p>由于写这篇文章是在外地，身边的设备只有一台 iPad，不能获取到数据进行特征提取，也不能写代码，所以接下来的特征提取用探讨的方式，下次再补充代码。</p>
<p>首先是射门前的事件，在获取射门事件时通过 <code>id - 1</code> 可以得到。</p>
<p>查看之前写的文章 <a href="https://tanzhijian.org/posts/invincible01">不败赛季传球路线图探索 01</a> 在 type_name 里有 'Dribbled Past', 'Dribble' ，可以获取到特征，射门是否来自完成盘带后。</p>
<p>直塞和传中，在 columns 里有 pass_cross，但没有直塞球 through，如果不能通过已有特征判定，则只能假设计算：传球与射门坐标连接的线，与射门的 y 轴形成的夹角小于 45 度，且最后射门类型为脚，则可以判定成直塞球，其余的均为传中，如下草图所示：</p>
<p><img src="https://s2.loli.net/2023/05/20/4qnLOPTJ6jad5gB.png" alt="through_ball.png" /></p>
<p>传中类型也通过最后的射门判定，用脚是低球传中，头球或其他则是高球传中。</p>
<p>射门部位在 StatsBomb 的公开数据里并没有球员的相关数据，不然可以通过判定射门时用脚和球员惯用脚是否为逆足，来获得更加准确的特征。</p>
<p>而防守区域或者密度，在视频里解释为不仅仅是防守者，还有进攻者——他的队友在哪里，都是潜在的阻挡射门的球员。虽然我并不认同这是个有用的特征，但还是把它加进来。采取的方式为射门位置 x 轴之后的球员均为防守区域的人数。</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季射门探索 01: xG</title>
    <link href="https://tanzhijian.org/posts/invincible_05"></link>
    <id>1684157980.5444288</id>
    <updated>2023-05-15T21:39:40Z</updated>
    <published>2023-05-15T21:39:40Z</published>
    <author><name>tanzhijian</name></author>
    <summary>从 xG 开始。训练一个 xG 的模型方便之后的探索使用
</summary>
    <content type="html">
      <h1>阿森纳不败赛季射门探索 01: xG</h1>
<p>从 xG 开始。训练一个 xG 的模型方便之后的探索使用</p>
<h2>预处理数据</h2>
<p>由于数据同样出自 Statsbomb，所以数据集使用他们的 opendata，获取 competitions 一共有 43 个赛季的不同性质比赛可以使用，但由于比赛差异，需要去除女子足球的比赛，然后去除阿森纳不败赛季的比赛作为测试集，过滤以后还有 36 个赛季 828 场的比赛可以使用</p>
<p>接下来获取所有的比赛事件，以及随之的跟踪数据事件，有一些需要注意的处理方法:</p>
<pre><code class="language-python"># 使用 mplsoccer 获取数据，每场比赛事件分别是 events, related, freeze, tactics
events = match[0]
tracks = match[2]

# 获取射门事件
# 把 Statsbomb 的坐标从 120 80 转换为 105 68 是方便之后绘图使用
shots = events.loc[events[&quot;type_name&quot;] == &quot;Shot&quot;].copy()
x_formula = lambda x: x * 105 / 120
y_formula = lambda x: x * 68 / 80
shots.x = shots.x.apply(x_formula)
shots.y = shots.y.apply(y_formula)
tracks.x = tracks.x.apply(x_formula)
tracks.y = tracks.y.apply(y_formula)
</code></pre>
<p>然后过滤掉定位球射门，以及未跟踪守门员的射门以后，还剩下 19174 条射门事件，数据不算大，但可以训练模型了</p>
<h2>特征提取</h2>
<p>如何选择特征呢，既然使用 Statsbomb 的数据，不妨找找他在这方面的资料，于是找到了 Statsbomb 发布的这条推特 <a href="https://twitter.com/StatsBomb/status/1650847925197471745">https://twitter.com/StatsBomb/status/1650847925197471745</a>已经有了答案：</p>
<blockquote>
<p>Not all xG is created equal.</p>
<p>StatsBomb's xG model includes:</p>
<ul>
<li>the positioning of the goalkeeper</li>
<li>the positioning of the surrounding defenders and attackers</li>
<li>the height of the ball at the moment the shot is struck</li>
</ul>
</blockquote>
<p>结合推特里面的视频，总结出 Statsbomb 的 xG 主要使用以下特征：</p>
<ul>
<li>射门距离</li>
<li>射门角度</li>
<li>基础 xg</li>
<li>守门员的位置</li>
<li>守门员与射门的距离</li>
<li>射门是否比守门员更接近球门</li>
<li>干扰射门的防守球员</li>
<li>射门与球门形成的三角形内防守球员</li>
<li>射门与球门形成的三角形内进攻球员</li>
<li>射门时球的高度</li>
</ul>
<p>其中干扰射门的防守球员是一个不好把握的特征，在这里假设射门时球半径 1 米内的防守球员都属于干扰射门</p>
<p>而射门时球的高度在没有具体的数据情况下是个更难的特征，大致原理为球的高度越高，xG 越低，脚射门比较准，而头球在同样距离的情况下更难把握住。Statsbomb 射门事件关于这一项特征 body_part_name 其中只包含了['Right Foot', 'Head', 'Left Foot', 'Other']，所以仍然需要假设。询问 chatgpt，男子足球运动员平均身高为 1.8 米（感觉偏高？），所以假设头球的高度统一为 1.8，脚下射门为 0.01, 其他可以理解为胸口，大腿等非常规部位，为 1.0</p>
<p>由于特征提取是一项不小的工程，所以在 GitHub 创建了一个库 <a href="https://github.com/tanzhijian/football-calculator">https://github.com/tanzhijian/football-calculator</a> ，如果查看时代码已经修改了，可以回滚到这篇文章写的日期，也就是 2023-05-14</p>
<h2>训练模型</h2>
<p>特征提取完毕以后可以得到一个 (19174, 10) 型状的数据集，开始创建一个神经网络进行训练，由于我并不擅长机器学习，所以随便写了一个先训练着，训练数据集和验证数据集 8:2，然后创建模型：</p>
<pre><code class="language-python">model = tf.keras.Sequential([
    layers.Dense(10, activation=&quot;relu&quot;, input_shape=(10,)),
    layers.Dense(10, activation=&quot;relu&quot;),
    layers.Dense(1, activation=&quot;sigmoid&quot;)
])
model.compile(
    optimizer=&#x27;adam&#x27;,
    loss=&quot;binary_crossentropy&quot;, 
    metrics=[&quot;accuracy&quot;]
)
history = model.fit(
    X_train, 
    y_train, 
    validation_data=(X_val, y_val),
    batch_size=32, 
    epochs=50,
)
</code></pre>
<p>测试数据库使用不败赛季的 832 个射门事件</p>
<pre><code class="language-python"># 计算精确度，召回率和 f1 分数
report = classification_report(y_test, y_pred)
print(report)
</code></pre>
<pre><code>              precision    recall  f1-score   support

           0       0.92      1.00      0.95       754
           1       0.75      0.12      0.20        78

    accuracy                           0.91       832
   macro avg       0.83      0.56      0.58       832
weighted avg       0.90      0.91      0.88       832
</code></pre>
<p>分数有点惨，但考虑到数据库大小，推断出的特征，一些乱七八糟的假设，随便设置的神经网络，能有这样也还不错了</p>
<p>接下来计算 xG 并查看</p>
<pre><code class="language-python">invincible_shots.groupby([&quot;player_name&quot;])[&quot;xg&quot;].sum().sort_values(
    ascending=False
)[:5].reset_index()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Thierry Henry</td>
      <td>15.798578</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Robert Pirès</td>
      <td>6.998034</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Fredrik Ljungberg</td>
      <td>4.917759</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dennis Bergkamp</td>
      <td>4.257910</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Kolo Habib Touré</td>
      <td>3.186363</td>
    </tr>
  </tbody>
</table>
</div>
<p>Statsbomb 数据里面有自带计算完毕的 xG 可以作为标准</p>
<pre><code class="language-python">invincible_shots.groupby([&quot;player_name&quot;])[&quot;shot_statsbomb_xg&quot;].sum().sort_values(
    ascending=False
)[:5].reset_index()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>shot_statsbomb_xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Thierry Henry</td>
      <td>17.330713</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Robert Pirès</td>
      <td>6.959468</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Fredrik Ljungberg</td>
      <td>5.271573</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Dennis Bergkamp</td>
      <td>4.135871</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Patrick Vieira</td>
      <td>3.469172</td>
    </tr>
  </tbody>
</table>
</div>
<p>还是有差异，考虑到上面提到的因素，可以接受</p>
<p>查看一些个别的</p>
<pre><code class="language-python">invincible_shots[[&quot;player_name&quot;, &quot;xg&quot;, &quot;shot_statsbomb_xg&quot;]].head(10)
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_name</th>
      <th>xg</th>
      <th>shot_statsbomb_xg</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Dennis Bergkamp</td>
      <td>0.153065</td>
      <td>0.193885</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Thierry Henry</td>
      <td>0.032303</td>
      <td>0.007914</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Gilberto Aparecido da Silva</td>
      <td>0.102811</td>
      <td>0.125604</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Paul Butler</td>
      <td>0.085732</td>
      <td>0.065221</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>0.044693</td>
      <td>0.043912</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Ioan Viorel Ganea</td>
      <td>0.070132</td>
      <td>0.085242</td>
    </tr>
    <tr>
      <th>6</th>
      <td>Dennis Bergkamp</td>
      <td>0.021920</td>
      <td>0.018803</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Carl Cort</td>
      <td>0.062670</td>
      <td>0.051536</td>
    </tr>
    <tr>
      <th>8</th>
      <td>Ioan Viorel Ganea</td>
      <td>0.229663</td>
      <td>0.256359</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Kenny Miller</td>
      <td>0.044943</td>
      <td>0.027489</td>
    </tr>
  </tbody>
</table>
</div>
<p>暂时可以用，之后时间再来优化了</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 04</title>
    <link href="https://tanzhijian.org/posts/invincible_04"></link>
    <id>1682751927.7004185</id>
    <updated>2023-04-29T15:05:27Z</updated>
    <published>2023-04-29T15:05:27Z</published>
    <author><name>tanzhijian</name></author>
    <summary>这一次探索单个球员的进攻传球路线。首先还是画出热区图，准备数据的部分和前面一篇相同，就不重复写了，直接跳到 danger_passes
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 04</h1>
<p>这一次探索单个球员的进攻传球路线。首先还是画出热区图，准备数据的部分和前面一篇相同，就不重复写了，直接跳到 danger_passes</p>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen, VerticalPitch
</code></pre>
<pre><code class="language-python">danger_passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>minute</th>
      <th>second</th>
      <th>player_name</th>
      <th>player_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>52.6</td>
      <td>54.3</td>
      <td>54.6</td>
      <td>45.0</td>
      <td>8</td>
      <td>4</td>
      <td>Patrick Vieira</td>
      <td>15515.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>69.9</td>
      <td>28.5</td>
      <td>102.0</td>
      <td>26.9</td>
      <td>8</td>
      <td>8</td>
      <td>Eduardo César Daude Gaspar</td>
      <td>26014.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>102.0</td>
      <td>26.9</td>
      <td>104.7</td>
      <td>37.6</td>
      <td>8</td>
      <td>10</td>
      <td>Ashley Cole</td>
      <td>12529.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>60.0</td>
      <td>45.6</td>
      <td>68.9</td>
      <td>33.9</td>
      <td>12</td>
      <td>7</td>
      <td>Robert Pirès</td>
      <td>19312.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>68.5</td>
      <td>33.9</td>
      <td>79.1</td>
      <td>31.1</td>
      <td>12</td>
      <td>9</td>
      <td>Eduardo César Daude Gaspar</td>
      <td>26014.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>探索单个球员</h2>
<p>作为威胁传球的核心，首先来探索皮雷，手动在名单里获取皮雷的 id，然后过滤</p>
<pre><code class="language-python">bins = (6, 5)
</code></pre>
<pre><code class="language-python">pires = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 19312]
</code></pre>
<pre><code class="language-python">def plot_player_passes(player, passes):
    pitch = Pitch(line_zorder=2, line_color=&quot;grey&quot;)
    fig, ax = pitch.grid(
        grid_height=0.9,
        title_height=0.06,
        axis=False,
        endnote_height=0.04,
        title_space=0,
        endnote_space=0,
    )

    bin_statistic = pitch.bin_statistic(
        player.x,
        player.y,
        statistic=&quot;count&quot;,
        bins=bins,
        normalize=False,
    )

    # 制作热区图
    pcm = pitch.heatmap(
        bin_statistic, 
        cmap=&quot;Reds&quot;, 
        # edgecolor=&quot;grey&quot;, 
        ax=ax[&quot;pitch&quot;],
    )

    # 绘制传球路线
    pitch.arrows(
        passes.x,
        passes.y,
        passes.end_x,
        passes.end_y,
        color=&quot;black&quot;,
        alpha=1,
        width=2,
        ax=ax[&quot;pitch&quot;],
    )

    fig.suptitle(f&quot;{player.iloc[0].player_name}&quot;, fontsize=30)
    plt.show()
</code></pre>
<pre><code class="language-python">plot_player_passes(pires, pires)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/6ujT13XKcx7EnOg.png" alt="attacking_play_pires_01.png" /></p>
<p>这样的路线看起来未免杂乱，这里使用 Opta 的一种传球表现图：球场分成 10 * 10 的区域，每一块区域传球次数越多颜色越深，箭头表示此区域的平均传球方向</p>
<pre><code class="language-python">bins = (10, 10)
</code></pre>
<pre><code class="language-python">def binning_groupby_mean(player):
    x_bins = [i for i in range(0, 121, 120 // bins[0])]
    y_bins = [i for i in range(0, 81, 80 // bins[1])]
    player[&#x27;x_bin&#x27;] = pd.cut(player[&#x27;x&#x27;], x_bins)
    player[&#x27;y_bin&#x27;] = pd.cut(player[&#x27;y&#x27;], y_bins)
    return player.groupby([&#x27;x_bin&#x27;, &#x27;y_bin&#x27;]).mean()
</code></pre>
<pre><code class="language-python">mean_passes = binning_groupby_mean(pires)
plot_player_passes(pires, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/OtbKrZBPfMTLyaF.png" alt="attacking_play_pires_02.png" /></p>
<p>边路进攻核心活动区域，次数最多的是左路肋部区域，在较少拿球的区域传球的距离比较长，到了不是自己的位置会将球传到熟悉的区域而不是就地组织，很少有长距离传中路线</p>
<pre><code class="language-python">vieira = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15515]
mean_passes = binning_groupby_mean(vieira)
plot_player_passes(vieira, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/DmBf7sAeSutwWM1.png" alt="attacking_play_vieira.png" /></p>
<p>覆盖了整个中场，核心传球区域与皮雷很近，传球选择路线更偏向左路</p>
<pre><code class="language-python">henry = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15516]
mean_passes = binning_groupby_mean(henry)
plot_player_passes(henry, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/dv3SfFq8Z4QpCXb.png" alt="attacking_play_henry.png" /></p>
<p>与印象不同的是，在中路禁区前沿有着大量的传球，且都是向前的路线，往禁区送出了大量的威胁球，所以在进球同时会收获那么多的助攻</p>
<pre><code class="language-python">player = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15042]
mean_passes = binning_groupby_mean(player)
plot_player_passes(player, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/tPTJrEHj97U5pd1.png" alt="attacking_play_bergkamp.png" /></p>
<p>活动位置更像是进攻型中场，传球也大多找的禁区前的队友</p>
<pre><code class="language-python">player = danger_passes.loc[danger_passes[&#x27;player_id&#x27;] == 15754]
mean_passes = binning_groupby_mean(player)
plot_player_passes(player, mean_passes)
</code></pre>
<p><img src="https://s2.loli.net/2023/04/29/GVHYfwemKSIEyX2.png" alt="attacking_play_ljungberg.png" /></p>
<p>与皮雷不一样的是，就地选择进攻传球更为频繁，习惯性活动范围固定在几块，可能与他场上位置更多变有关</p>
<p>传球路线图就到这里了，下一次探索些别的</p>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 03</title>
    <link href="https://tanzhijian.org/posts/invincible_03"></link>
    <id>1681920025.721563</id>
    <updated>2023-04-20T00:00:25Z</updated>
    <published>2023-04-20T00:00:25Z</published>
    <author><name>tanzhijian</name></author>
    <summary>这次用热区图的形式来探索，与平时所看的全场比赛事件分布热区图不一样的是，用的是危险传球——这次把射门前 15 秒内的传球都视为危险传球。
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 03</h1>
<p>这次用热区图的形式来探索，与平时所看的全场比赛事件分布热区图不一样的是，用的是危险传球——这次把射门前 15 秒内的传球都视为危险传球。</p>
<p>前面获取数据部分和上一篇大致相同</p>
<h2>import</h2>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen, VerticalPitch
</code></pre>
<pre><code class="language-python">parser = Sbopen()
matches = parser.match(competition_id=2, season_id=44)
matches_events = []
for match_id in matches[&#x27;match_id&#x27;]:
    data = parser.event(match_id)
    matches_events.append(data[0])
</code></pre>
<h2>获取危险传球</h2>
<p>获取阿森纳所有比赛的射门和准确传球，且传球不是定位球，然后寻找射门前 15 秒的传球，对于时间需要考虑上下半场，伤停补时的特殊处理</p>
<pre><code class="language-python">danger_passes = pd.DataFrame()
for events in matches_events:
    # 上下半场
    for period in [1, 2]:
        # 只保留没有定位球的准确传球
        pass_filter = (
            events.team_name == &#x27;Arsenal&#x27;) &amp; (
            events.type_name == &quot;Pass&quot;) &amp; (
            events.outcome_name.isnull()) &amp; (
            events.period == period) &amp; (
            events.sub_type_name.isnull())
        passes = events.loc[
            pass_filter, 
            [
                &quot;x&quot;, &quot;y&quot;, &quot;end_x&quot;, &quot;end_y&quot;, 
                &quot;minute&quot;, &quot;second&quot;, &quot;player_name&quot;,
            ],
        ]
        # 只保留阿森纳的射门
        shot_filter = (
            events.team_name == &#x27;Arsenal&#x27;) &amp; (
            events.type_name == &quot;Shot&quot;) &amp; (
            events.period == period)
        shots = events.loc[shot_filter, [&quot;minute&quot;, &quot;second&quot;]]
        shot_times = shots[&#x27;minute&#x27;] * 60 + shots[&#x27;second&#x27;]
        
        # 设置为射门前 15 秒
        shot_anchor = 15
        shot_start = shot_times - shot_anchor
        
        # 处理时间
        shot_start = shot_start.apply(lambda i: i if i &gt; 0 else (period - 1) * 45)
        pass_times = passes[&#x27;minute&#x27;] * 60 + passes[&#x27;second&#x27;]

        pass_to_shot = pass_times.apply(
            lambda x: True in ((shot_start &lt; x) &amp; (x &lt; shot_times)).unique())

        # 只保留危险传球
        danger_passes_period = passes.loc[pass_to_shot]
        danger_passes = pd.concat(
            [danger_passes, danger_passes_period], 
            ignore_index=True
        )
</code></pre>
<pre><code class="language-python">danger_passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>minute</th>
      <th>second</th>
      <th>player_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>52.6</td>
      <td>54.3</td>
      <td>54.6</td>
      <td>45.0</td>
      <td>8</td>
      <td>4</td>
      <td>Patrick Vieira</td>
    </tr>
    <tr>
      <th>1</th>
      <td>69.9</td>
      <td>28.5</td>
      <td>102.0</td>
      <td>26.9</td>
      <td>8</td>
      <td>8</td>
      <td>Eduardo César Daude Gaspar</td>
    </tr>
    <tr>
      <th>2</th>
      <td>102.0</td>
      <td>26.9</td>
      <td>104.7</td>
      <td>37.6</td>
      <td>8</td>
      <td>10</td>
      <td>Ashley Cole</td>
    </tr>
    <tr>
      <th>3</th>
      <td>60.0</td>
      <td>45.6</td>
      <td>68.9</td>
      <td>33.9</td>
      <td>12</td>
      <td>7</td>
      <td>Robert Pirès</td>
    </tr>
    <tr>
      <th>4</th>
      <td>68.5</td>
      <td>33.9</td>
      <td>79.1</td>
      <td>31.1</td>
      <td>12</td>
      <td>9</td>
      <td>Eduardo César Daude Gaspar</td>
    </tr>
  </tbody>
</table>
</div>
<h2>绘制热区图</h2>
<p>这次在球场上使用 6 * 5 的格子来制作，其中宽度区域对应中肋边路，六块长度区域在瓜迪奥拉的战术板经常能看到</p>
<pre><code class="language-python">pitch = Pitch(line_zorder=2, line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0
)

bin_statistic = pitch.bin_statistic(
    danger_passes.x, danger_passes.y, 
    statistic=&#x27;count&#x27;, bins=(6, 5), normalize=False,
)

# 绘制热区图
pcm = pitch.heatmap(
    bin_statistic, cmap=&#x27;Reds&#x27;, edgecolor=&#x27;black&#x27;, ax=ax[&#x27;pitch&#x27;]
)

# 绘制说明
ax_cbar = fig.add_axes((1, 0.093, 0.03, 0.786))
cbar = plt.colorbar(pcm, cax=ax_cbar)

fig.suptitle(&#x27;Danger passes by Arsenal&#x27;, fontsize=30)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/19/9yWTgXGkQbl2vKf.png" alt="arsenal_0304_danger_pass_heatmap.png" /></p>
<h2>绘制参与危险传球最多球员的图表</h2>
<p>为了更加清晰的探索，将球员参与的传球次数绘制出来</p>
<p>这次偷个懒就不与 nickname 结合了</p>
<pre><code class="language-python">passes_count = danger_passes.groupby([&#x27;player_name&#x27;]).x.count()

ax = passes_count.plot.barh(passes_count)
ax.set_xlabel(&#x27;Number of danger passes&#x27;)
ax.set_ylabel(&#x27;&#x27;)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/19/IO2bqtkSLTKjhCg.png" alt="number_of_arsenal_0304_danger_pass.png" /></p>
<h2>结论</h2>
<ol>
<li>维埃拉-皮雷-亨利占据了形成射门的大多数传球，球会经过他们很多次，是整个进攻体系的核心</li>
<li>博格坎普受限于出场(21次首发8次替补)，他的进攻参与度重要性不亚于 1</li>
<li>亨利作为终结者，在进攻传球网络中也有如此重要的数据，全能</li>
<li>左路肋部区域承担了推进至禁区的大多任务，</li>
<li>右路参与的控球大多数会通过中路交到左路，少部分会在右路传到禁区</li>
</ol>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 02</title>
    <link href="https://tanzhijian.org/posts/invincible_02"></link>
    <id>1681501683.1309137</id>
    <updated>2023-04-15T03:48:03Z</updated>
    <published>2023-04-15T03:48:03Z</published>
    <author><name>tanzhijian</name></author>
    <summary>上篇文章选取了其中一场的比赛，其主力阵容除了右边前卫帕洛尔，其余都是不败赛季夺冠的常规主力，这次的探索目标为整个赛季的所有比赛，作为常规主力的十一人传球路线图
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 02</h1>
<p>上篇文章选取了其中一场的比赛，其主力阵容除了右边前卫帕洛尔，其余都是不败赛季夺冠的常规主力，这次的探索目标为整个赛季的所有比赛，作为常规主力的十一人传球路线图</p>
<p>首先是获取 38 场比赛的数据集</p>
<h2>import</h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen
</code></pre>
<pre><code class="language-python"># 获取所有比赛的 id
parser = Sbopen()
matches = parser.match(competition_id=2, season_id=44)
</code></pre>
<pre><code class="language-python"># 获取所有比赛的事件数据集
events = []
for match_id in matches[&#x27;match_id&#x27;]:
    data = parser.event(match_id)
    # data[0] 为 event
    events.append(data[0])
</code></pre>
<h2>获取需要的数据</h2>
<p>现在需要找到首发 11 人的 player_id, 这一步手动来完成了，也就是上一篇文章的首发阵容 id，然后把帕洛尔换成永贝里</p>
<pre><code class="language-python">invincible_11 = [
    20015,
    40222, 38412, 15637, 12529,
    15754, 40221, 15515, 19312,
    15042, 15516,
]
</code></pre>
<pre><code class="language-python"># 手动获取一场全部 11 人阵容的比赛
lineup = parser.lineup(3749257)
invincible_11 = pd.merge(
    pd.DataFrame({&#x27;player_id&#x27;: invincible_11}),
    lineup[[&#x27;player_id&#x27;, &#x27;player_nickname&#x27;,]],
    on=&#x27;player_id&#x27;
)
</code></pre>
<p>接下来设置过滤条件，和上一篇文章差不多：</p>
<ol>
<li>对手的事件</li>
<li>失败的传球</li>
<li>传球队员与接球队员是否 invincible_11</li>
</ol>
<pre><code class="language-python">def mask(events):
    _filter = (
    events.type_name == &#x27;Pass&#x27;) &amp; (
    events.team_name == &quot;Arsenal&quot;) &amp; (
    events.player_id.isin(invincible_11.player_id)) &amp; (
    events.pass_recipient_id.isin(invincible_11.player_id)) &amp; (
    events.outcome_name.isnull())
    
    passes = events.loc[_filter, [
        &#x27;x&#x27;, &#x27;y&#x27;, &#x27;end_x&#x27;, &#x27;end_y&#x27;,
        &#x27;player_id&#x27;, &#x27;player_name&#x27;, &#x27;pass_recipient_name&#x27;, &#x27;pass_recipient_id&#x27;
    ]]
    return passes
</code></pre>
<pre><code class="language-python">passes = pd.concat([mask(event) for event in events])
</code></pre>
<pre><code class="language-python">passes = passes.reset_index()
passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>index</th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>player_id</th>
      <th>player_name</th>
      <th>pass_recipient_name</th>
      <th>pass_recipient_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>61.0</td>
      <td>40.1</td>
      <td>61.4</td>
      <td>43.6</td>
      <td>15516.0</td>
      <td>Thierry Henry</td>
      <td>Dennis Bergkamp</td>
      <td>15042.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>12</td>
      <td>37.6</td>
      <td>2.9</td>
      <td>23.4</td>
      <td>24.7</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>11.1</td>
      <td>9.7</td>
      <td>7.7</td>
      <td>21.5</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>75</td>
      <td>17.7</td>
      <td>11.5</td>
      <td>26.2</td>
      <td>8.1</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Robert Pirès</td>
      <td>19312.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>97</td>
      <td>25.3</td>
      <td>29.3</td>
      <td>30.0</td>
      <td>49.1</td>
      <td>38412.0</td>
      <td>Kolo Habib Touré</td>
      <td>Laureano Bisan-Etame Mayer</td>
      <td>40222.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>画图</h2>
<pre><code class="language-python"># 计算位置和大小
scatter = pd.DataFrame()
for i, _id in enumerate(passes[&#x27;player_id&#x27;].unique()):
    pass_x = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;x&#x27;].to_numpy()
    pass_y = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;y&#x27;].to_numpy()
    rec_x = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_x&#x27;].to_numpy()
    rec_y = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_y&#x27;].to_numpy()
    scatter.at[i, &#x27;player_id&#x27;] = _id
    
    # 计算每个点的 x 和 y，位置为传球和接球的平均值
    scatter.at[i, &#x27;x&#x27;] = np.mean(np.concatenate([pass_x, rec_x]))
    scatter.at[i, &#x27;y&#x27;] = np.mean(np.concatenate([pass_y, rec_y]))
    
    # 计算传球数
    scatter.at[i, &#x27;count&#x27;] = passes.loc[
        passes[&#x27;player_id&#x27;] == _id].count().iloc[0]
</code></pre>
<pre><code class="language-python"># 位置大小
scatter[&#x27;marker_size&#x27;] = scatter[&#x27;count&#x27;] / scatter[&#x27;count&#x27;].max() * 3000
</code></pre>
<pre><code class="language-python"># 合并名字
scatter = pd.merge(
    scatter,
    invincible_11,
    on=&#x27;player_id&#x27;
)
</code></pre>
<pre><code class="language-python"># 计算球员之间的传球次数
passes[&#x27;pair_key&#x27;] = passes.apply(
    lambda x: &#x27;-&#x27;.join(sorted([str(x[&#x27;player_id&#x27;]), 
                               str(x[&#x27;pass_recipient_id&#x27;])])),
    axis=1,
)
lines = passes.groupby([&#x27;pair_key&#x27;]).x.count().reset_index()
lines.rename({&#x27;x&#x27;: &#x27;pass_count&#x27;}, axis=&#x27;columns&#x27;, inplace=True)

# 设定一个阈值，可以尝试研究它在更改时如何变化
lines = lines[lines[&#x27;pass_count&#x27;] &gt; 4 * 38]

# 绘制球场
pitch = Pitch(line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0,
)
# 球场上的位置
pitch.scatter(
    scatter.x, scatter.y, s=scatter.marker_size, 
    color=&#x27;red&#x27;, edgecolors=&#x27;grey&#x27;, linewidth=1, alpha=0.8,
    ax=ax[&#x27;pitch&#x27;], zorder=3,
)

# 填充球员名字
for i, row in scatter.iterrows():
    pitch.annotate(
        row.player_nickname, xy=(row.x, row.y), c=&#x27;black&#x27;, 
        va=&#x27;center&#x27;, ha=&#x27;center&#x27;, weight=&quot;bold&quot;, 
        size=14, ax=ax[&quot;pitch&quot;], zorder=4,
    )
    
for i, row in lines.iterrows():
    player1 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[0])
    player2 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[1])
    
    # 取球员的平均位置在他们之间画一条线
    player1_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;x&#x27;].iloc[0]
    player1_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;y&#x27;].iloc[0]
    player2_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;x&#x27;].iloc[0]
    player2_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;y&#x27;].iloc[0]
    passes_count = row[&#x27;pass_count&#x27;]
    # 调整线宽，传球的次数越多，线越宽
    line_width = passes_count / lines[&#x27;pass_count&#x27;].max() * 15

    pitch.lines(
        player1_x, player1_y, player2_x, player2_y,
        alpha=0.8, lw=line_width, zorder=2, color=&#x27;red&#x27;, ax=ax[&#x27;pitch&#x27;]
    )
    
fig.suptitle(&#x27;Invincible 11&#x27;, fontsize=30)
plt.show()

</code></pre>
<p><img src="https://s2.loli.net/2023/04/15/LN5KPG6efpjFRMC.png" alt="invincible_11_passing_networks.png" /></p>
<h2>结论</h2>
<p>高中时期我和好友无数次在实况足球里面模拟这一套 442，现在看到还原出来蛮感慨</p>
<ol>
<li>莱曼的出球线路，图雷，较少直接找两个边后卫，很少开大脚</li>
<li>图雷担任出球中卫</li>
<li>劳伦这一侧的球权比想象中多</li>
<li>吉尔伯托在后场出球系统中几乎和维埃拉同样重要，但他没有向前传球的路线</li>
<li>托后三人组，坎贝尔，图雷，吉尔伯托</li>
<li>阿什利科尔 - 皮雷 - 亨利是主要的推进线路</li>
<li>永贝里的主要进攻路线是传中找亨利</li>
<li>皮雷当之无愧的进攻核心</li>
<li>所有的进攻球都在找亨利</li>
<li>博格坎普可能受制于出场时间，并没有想象中重要</li>
</ol>

    </content>
  </entry>
  <entry>
    <title>阿森纳不败赛季传球路线图探索 01</title>
    <link href="https://tanzhijian.org/posts/invincible01"></link>
    <id>1681234440.864004</id>
    <updated>2023-04-12T01:34:00Z</updated>
    <published>2023-04-12T01:34:00Z</published>
    <author><name>tanzhijian</name></author>
    <summary>statsbomb 有一些有趣的公开数据，比如梅西的职业生涯，阿森纳的不败赛季，最近在上足球数据可视化的课程，刚好拿来玩一玩。
</summary>
    <content type="html">
      <h1>阿森纳不败赛季传球路线图探索 01</h1>
<p>statsbomb 有一些有趣的公开数据，比如梅西的职业生涯，阿森纳的不败赛季，最近在上足球数据可视化的课程，刚好拿来玩一玩。</p>
<p>通过 competitions 找到英超联赛 0304赛季的 id，其中只有阿森纳的比赛，这次随便获取一场比赛来试手，2004 年 4 月 25 日北伦敦德比，阿森纳在白鹿巷球场 2:2 战平热刺，高举起英格兰超级联赛冠军奖杯，就它了。</p>
<h2>import</h2>
<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mplsoccer import Pitch, Sbopen

match_id = 3749068
</code></pre>
<pre><code class="language-python">parser = Sbopen()
events, related, freeze, tactics = parser.event(match_id)
</code></pre>
<pre><code class="language-python"># 检查一下数据集
events.info()
</code></pre>
<pre><code>&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;
RangeIndex: 3156 entries, 0 to 3155
Data columns (total 77 columns):
 #   Column                          Non-Null Count  Dtype  
---  ------                          --------------  -----  
 0   id                              3156 non-null   object 
 1   index                           3156 non-null   int64  
 2   period                          3156 non-null   int64  
 3   timestamp                       3156 non-null   object 
 4   minute                          3156 non-null   int64  
 5   second                          3156 non-null   int64  
 6   possession                      3156 non-null   int64  
 7   duration                        2355 non-null   float64
 8   match_id                        3156 non-null   int64  
 9   type_id                         3156 non-null   int64  
 10  type_name                       3156 non-null   object 
 11  possession_team_id              3156 non-null   int64  
 12  possession_team_name            3156 non-null   object 
 13  play_pattern_id                 3156 non-null   int64  
 14  play_pattern_name               3156 non-null   object 
 15  team_id                         3156 non-null   int64  
 16  team_name                       3156 non-null   object 
 17  tactics_formation               3 non-null      float64
 18  player_id                       3145 non-null   float64
 19  player_name                     3145 non-null   object 
 20  position_id                     3145 non-null   float64
 21  position_name                   3145 non-null   object 
 22  pass_recipient_id               801 non-null    float64
 23  pass_recipient_name             801 non-null    object 
 24  pass_length                     879 non-null    float64
 25  pass_angle                      879 non-null    float64
 26  pass_height_id                  879 non-null    float64
 27  pass_height_name                879 non-null    object 
 28  end_x                           1571 non-null   float64
 29  end_y                           1571 non-null   float64
 30  body_part_id                    899 non-null    float64
 31  body_part_name                  899 non-null    object 
 32  sub_type_id                     322 non-null    float64
 33  sub_type_name                   322 non-null    object 
 34  x                               3139 non-null   float64
 35  y                               3139 non-null   float64
 36  outcome_id                      434 non-null    float64
 37  outcome_name                    434 non-null    object 
 38  under_pressure                  670 non-null    float64
 39  counterpress                    82 non-null     float64
 40  off_camera                      65 non-null     float64
 41  aerial_won                      38 non-null     object 
 42  out                             34 non-null     float64
 43  ball_recovery_recovery_failure  11 non-null     object 
 44  pass_switch                     38 non-null     object 
 45  foul_committed_advantage        5 non-null      object 
 46  foul_won_advantage              5 non-null      object 
 47  technique_id                    50 non-null     float64
 48  technique_name                  50 non-null     object 
 49  pass_assisted_shot_id           16 non-null     object 
 50  pass_goal_assist                3 non-null      object 
 51  shot_open_goal                  1 non-null      object 
 52  shot_statsbomb_xg               23 non-null     float64
 53  end_z                           19 non-null     float64
 54  shot_key_pass_id                16 non-null     object 
 55  shot_first_time                 8 non-null      object 
 56  goalkeeper_position_id          23 non-null     float64
 57  goalkeeper_position_name        23 non-null     object 
 58  pass_cross                      15 non-null     object 
 59  dribble_overrun                 3 non-null      object 
 60  ball_recovery_offensive         2 non-null      object 
 61  pass_shot_assist                13 non-null     object 
 62  foul_won_defensive              9 non-null      object 
 63  pass_deflected                  2 non-null      object 
 64  half_start_late_video_start     2 non-null      object 
 65  substitution_replacement_id     5 non-null      float64
 66  substitution_replacement_name   5 non-null      object 
 67  foul_committed_card_id          2 non-null      float64
 68  foul_committed_card_name        2 non-null      object 
 69  dribble_nutmeg                  1 non-null      object 
 70  shot_one_on_one                 1 non-null      object 
 71  pass_cut_back                   1 non-null      object 
 72  block_offensive                 1 non-null      object 
 73  foul_committed_penalty          1 non-null      object 
 74  foul_won_penalty                1 non-null      object 
 75  bad_behaviour_card_id           1 non-null      float64
 76  bad_behaviour_card_name         1 non-null      object 
dtypes: float64(26), int64(10), object(41)
memory usage: 1.9+ MB
</code></pre>
<pre><code class="language-python"># 查看有哪些事件
events[&#x27;type_name&#x27;].unique()
</code></pre>
<pre><code>array([&#x27;Starting XI&#x27;, &#x27;Half Start&#x27;, &#x27;Pass&#x27;, &#x27;Ball Receipt&#x27;, &#x27;Carry&#x27;,
       &#x27;Block&#x27;, &#x27;Ball Recovery&#x27;, &#x27;Pressure&#x27;, &#x27;Duel&#x27;, &#x27;Clearance&#x27;,
       &#x27;Foul Committed&#x27;, &#x27;Foul Won&#x27;, &#x27;Dribbled Past&#x27;, &#x27;Dribble&#x27;, &#x27;Shot&#x27;,
       &#x27;Goal Keeper&#x27;, &#x27;Dispossessed&#x27;, &#x27;Interception&#x27;, &#x27;Miscontrol&#x27;,
       &#x27;50/50&#x27;, &#x27;Offside&#x27;, &#x27;Half End&#x27;, &#x27;Substitution&#x27;, &#x27;Error&#x27;,
       &#x27;Tactical Shift&#x27;, &#x27;Bad Behaviour&#x27;], dtype=object)
</code></pre>
<p>由于换人了以后阵容战术就会变动，所以绘制首发传球图需要在第一次换人之前，找到第一次换人的事件</p>
<p>然后过滤掉：</p>
<ol>
<li>对手的事件</li>
<li>换人之后的事件，也就是index 小于 sub 的事件</li>
<li>失败的传球</li>
</ol>
<pre><code class="language-python">first_sub = events.loc[
    events[&#x27;type_name&#x27;] == &#x27;Substitution&#x27;].loc[
    events[&#x27;team_name&#x27;] == &quot;Arsenal&quot;].iloc[0]
first_sub
</code></pre>
<pre><code>id                         7900f48c-1308-4aa5-9ec8-37af5c06a6d7
index                                                      2335
period                                                        2
timestamp                                       00:21:42.293000
minute                                                       66
                                           ...                 
block_offensive                                             NaN
foul_committed_penalty                                      NaN
foul_won_penalty                                            NaN
bad_behaviour_card_id                                       NaN
bad_behaviour_card_name                                     NaN
Name: 2334, Length: 77, dtype: object
</code></pre>
<pre><code class="language-python">_filter = (
    events.type_name == &#x27;Pass&#x27;) &amp; (
    events.team_name == &quot;Arsenal&quot;) &amp; (
    events.index &lt; first_sub[&#x27;index&#x27;]) &amp; (
    events.outcome_name.isnull())
</code></pre>
<pre><code class="language-python">_filter.head()
</code></pre>
<pre><code>0    False
1    False
2    False
3    False
4     True
dtype: bool
</code></pre>
<pre><code class="language-python"># 获取必要的数据
passes = events.loc[_filter, [
    &#x27;x&#x27;, &#x27;y&#x27;, &#x27;end_x&#x27;, &#x27;end_y&#x27;,
    &#x27;player_id&#x27;, &#x27;player_name&#x27;, &#x27;pass_recipient_name&#x27;, &#x27;pass_recipient_id&#x27;
]]
</code></pre>
<pre><code class="language-python">passes.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>x</th>
      <th>y</th>
      <th>end_x</th>
      <th>end_y</th>
      <th>player_id</th>
      <th>player_name</th>
      <th>pass_recipient_name</th>
      <th>pass_recipient_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>60.0</td>
      <td>40.0</td>
      <td>62.3</td>
      <td>43.5</td>
      <td>15516.0</td>
      <td>Thierry Henry</td>
      <td>Dennis Bergkamp</td>
      <td>15042.0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>62.0</td>
      <td>43.5</td>
      <td>47.2</td>
      <td>30.7</td>
      <td>15042.0</td>
      <td>Dennis Bergkamp</td>
      <td>Patrick Vieira</td>
      <td>15515.0</td>
    </tr>
    <tr>
      <th>9</th>
      <td>47.2</td>
      <td>29.5</td>
      <td>38.2</td>
      <td>12.1</td>
      <td>15515.0</td>
      <td>Patrick Vieira</td>
      <td>Ashley Cole</td>
      <td>12529.0</td>
    </tr>
    <tr>
      <th>12</th>
      <td>38.2</td>
      <td>12.1</td>
      <td>31.7</td>
      <td>26.3</td>
      <td>12529.0</td>
      <td>Ashley Cole</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>15637.0</td>
    </tr>
    <tr>
      <th>15</th>
      <td>28.8</td>
      <td>29.5</td>
      <td>48.4</td>
      <td>38.8</td>
      <td>15637.0</td>
      <td>Sulzeer Jeremiah ''Sol' Campbell</td>
      <td>Gilberto Aparecido da Silva</td>
      <td>40221.0</td>
    </tr>
  </tbody>
</table>
</div>
<h2>计算位置和大小</h2>
<p>对于每个球员，计算传球和接球的平均位置，然后计算每个球员到接球球员的传球次数，传球线路的粗细与之成正比</p>
<pre><code class="language-python">scatter = pd.DataFrame()
for i, _id in enumerate(passes[&#x27;player_id&#x27;].unique()):
    pass_x = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;x&#x27;].to_numpy()
    pass_y = passes.loc[passes[&#x27;player_id&#x27;] == _id][&#x27;y&#x27;].to_numpy()
    rec_x = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_x&#x27;].to_numpy()
    rec_y = passes.loc[passes[&#x27;pass_recipient_id&#x27;] == _id][&#x27;end_y&#x27;].to_numpy()
    scatter.at[i, &#x27;player_id&#x27;] = _id
    
    # 计算每个点的 x 和 y，位置为传球和接球的平均值
    scatter.at[i, &#x27;x&#x27;] = np.mean(np.concatenate([pass_x, rec_x]))
    scatter.at[i, &#x27;y&#x27;] = np.mean(np.concatenate([pass_y, rec_y]))
    
    # 计算传球数
    scatter.at[i, &#x27;count&#x27;] = passes.loc[
        passes[&#x27;player_id&#x27;] == _id].count().iloc[0]
    
# 位置大小
scatter[&#x27;marker_size&#x27;] = scatter[&#x27;count&#x27;] / scatter[&#x27;count&#x27;].max() * 1500
</code></pre>
<pre><code class="language-python">scatter
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>player_id</th>
      <th>x</th>
      <th>y</th>
      <th>count</th>
      <th>marker_size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>15516.0</td>
      <td>73.757692</td>
      <td>33.834615</td>
      <td>10.0</td>
      <td>306.122449</td>
    </tr>
    <tr>
      <th>1</th>
      <td>15042.0</td>
      <td>66.135897</td>
      <td>37.082051</td>
      <td>15.0</td>
      <td>459.183673</td>
    </tr>
    <tr>
      <th>2</th>
      <td>15515.0</td>
      <td>54.474194</td>
      <td>33.134409</td>
      <td>49.0</td>
      <td>1500.000000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12529.0</td>
      <td>52.920313</td>
      <td>7.568750</td>
      <td>35.0</td>
      <td>1071.428571</td>
    </tr>
    <tr>
      <th>4</th>
      <td>15637.0</td>
      <td>36.142857</td>
      <td>19.846429</td>
      <td>13.0</td>
      <td>397.959184</td>
    </tr>
    <tr>
      <th>5</th>
      <td>40221.0</td>
      <td>52.817460</td>
      <td>43.530159</td>
      <td>32.0</td>
      <td>979.591837</td>
    </tr>
    <tr>
      <th>6</th>
      <td>38412.0</td>
      <td>35.815909</td>
      <td>48.084091</td>
      <td>23.0</td>
      <td>704.081633</td>
    </tr>
    <tr>
      <th>7</th>
      <td>40222.0</td>
      <td>49.040351</td>
      <td>70.389474</td>
      <td>31.0</td>
      <td>948.979592</td>
    </tr>
    <tr>
      <th>8</th>
      <td>19312.0</td>
      <td>61.132308</td>
      <td>18.466154</td>
      <td>32.0</td>
      <td>979.591837</td>
    </tr>
    <tr>
      <th>9</th>
      <td>20015.0</td>
      <td>8.210000</td>
      <td>41.750000</td>
      <td>8.0</td>
      <td>244.897959</td>
    </tr>
    <tr>
      <th>10</th>
      <td>24972.0</td>
      <td>68.381081</td>
      <td>67.370270</td>
      <td>15.0</td>
      <td>459.183673</td>
    </tr>
  </tbody>
</table>
</div>
<h2>球员名及号码</h2>
<p>由于事件数据集只有简单的球员名字和 id，绘制图片时使用名字全称过长，比如 Laureano Bisan-Etame Mayer 这位大哥估计不少人反应不过来是谁，Lauren 就明白了。</p>
<p>需要从另一个数据集中获取</p>
<pre><code class="language-python">lineup = parser.lineup(match_id)
</code></pre>
<pre><code class="language-python">arsenal = lineup.loc[lineup[&#x27;team_name&#x27;] == &#x27;Arsenal&#x27;]
scatter = pd.merge(
    scatter, 
    arsenal[[&#x27;player_id&#x27;, &#x27;player_nickname&#x27;, &#x27;jersey_number&#x27;]], 
    on=&#x27;player_id&#x27;
)
</code></pre>
<h2>计算传球线路宽度</h2>
<p>计算线路宽度，需要根据传球和接球的组合对传球数据框进行分组，并计算他们之间的传球次数。最后一步设置了忽略传球次数少于 2 次的球员的阈值。可以尝试不同的值，根据可视化背后的信息调整它</p>
<pre><code class="language-python"># 计算球员之间的传球次数
passes[&#x27;pair_key&#x27;] = passes.apply(
    lambda x: &#x27;-&#x27;.join(sorted([str(x[&#x27;player_id&#x27;]), 
                               str(x[&#x27;pass_recipient_id&#x27;])])),
    axis=1,
)
lines = passes.groupby([&#x27;pair_key&#x27;]).x.count().reset_index()
lines.rename({&#x27;x&#x27;: &#x27;pass_count&#x27;}, axis=&#x27;columns&#x27;, inplace=True)
</code></pre>
<pre><code class="language-python"># 设定一个阈值，可以尝试研究它在更改时如何变化
lines = lines[lines[&#x27;pass_count&#x27;] &gt; 2]
</code></pre>
<pre><code class="language-python">lines.head()
</code></pre>
<div>
<table>
  <thead>
    <tr>
      <th></th>
      <th>pair_key</th>
      <th>pass_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>12529.0-15515.0</td>
      <td>20</td>
    </tr>
    <tr>
      <th>2</th>
      <td>12529.0-15516.0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>12529.0-15637.0</td>
      <td>8</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12529.0-19312.0</td>
      <td>21</td>
    </tr>
    <tr>
      <th>7</th>
      <td>12529.0-40221.0</td>
      <td>6</td>
    </tr>
  </tbody>
</table>
</div>
<h2>绘制路线</h2>
<pre><code class="language-python"># 绘制球场
pitch = Pitch(line_color=&#x27;grey&#x27;)
fig, ax = pitch.grid(
    grid_height=0.9, title_height=0.06, axis=False,
    endnote_height=0.04, title_space=0, endnote_space=0,
)
# 球场上的位置
pitch.scatter(
    scatter.x, scatter.y, s=scatter.marker_size, 
    color=&#x27;red&#x27;, edgecolors=&#x27;grey&#x27;, linewidth=1, alpha=1,
    ax=ax[&#x27;pitch&#x27;], zorder=3,
)

# 填充球员名字
for i, row in scatter.iterrows():
    pitch.annotate(
        row.player_nickname, xy=(row.x, row.y), c=&#x27;black&#x27;, 
        va=&#x27;center&#x27;, ha=&#x27;center&#x27;, weight=&quot;bold&quot;, 
        size=14, ax=ax[&quot;pitch&quot;], zorder=4,
    )
    
for i, row in lines.iterrows():
    player1 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[0])
    player2 = float(row[&#x27;pair_key&#x27;].split(&#x27;-&#x27;)[1])
    
    # 取球员的平均位置在他们之间画一条线
    player1_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;x&#x27;].iloc[0]
    player1_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player1][&#x27;y&#x27;].iloc[0]
    player2_x = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;x&#x27;].iloc[0]
    player2_y = scatter.loc[scatter[&#x27;player_id&#x27;] == player2][&#x27;y&#x27;].iloc[0]
    passes_count = row[&#x27;pass_count&#x27;]
    # 调整线宽，传球的次数越多，线越宽
    line_width = passes_count / lines[&#x27;pass_count&#x27;].max() * 10

    pitch.lines(
        player1_x, player1_y, player2_x, player2_y,
        alpha=1, lw=line_width, zorder=2, color=&#x27;red&#x27;, ax=ax[&#x27;pitch&#x27;]
    )
    
fig.suptitle(&#x27;2004-04-25, Tottenham Hotspur vs Arsenal&#x27;, fontsize=30)
plt.show()
</code></pre>
<p><img src="https://s2.loli.net/2023/04/11/1GzYOeHoiubdvLF.png" alt="ARS_VS_HOT_0304_passing_networks.png" /></p>

    </content>
  </entry>
  <entry>
    <title>关于这个博客</title>
    <link href="https://tanzhijian.org/posts/about_blog"></link>
    <id>1680936741.073004</id>
    <updated>2023-04-08T14:52:21Z</updated>
    <published>2023-04-08T14:52:21Z</published>
    <author><name>tanzhijian</name></author>
    <summary>内容没什么好说的，无非就是 GitHub Pages，加上比较懒，样式主题都没改，不过无所谓，以前把博客弄得好看回头文章几年没写一次也不是没有过。
</summary>
    <content type="html">
      <h1>关于这个博客</h1>
<p>内容没什么好说的，无非就是 GitHub Pages，加上比较懒，样式主题都没改，不过无所谓，以前把博客弄得好看回头文章几年没写一次也不是没有过。</p>
<p>但好歹要有一些必须的页面，所以写了一个<a href="https://github.com/tanzhijian/tanzhijian.github.io/blob/master/build.py">脚本</a>生成了 index，archive，以及最重要的 rss，以下是用 ChatGPT 生成的介绍：</p>
<blockquote>
<p>这段代码是一个用 Python 语言写的脚本，可以帮助我们生成一个博客网站。这个博客网站可以展示使用 Markdown 格式编写的博客文章。脚本会读取 &quot;posts&quot; 文件夹中的 Markdown 文件，将它们转换为 HTML 格式，并且使用 Jinja2 模板语言生成 Atom 订阅源、主页和归档页。</p>
<p>代码中定义了一些函数，它们会将 Markdown 文件转换为字典，然后使用 Jinja2 模板渲染字典数据，最终生成网站文件。其中 main 函数是整个程序的主要逻辑，它会读取 Markdown 文件夹中的所有文件，将它们转换为字典并排序，然后将字典数据填充到 Jinja2 模板中，最终生成网站文件。</p>
<p>这个脚本是一个简单的示例，可以作为生成静态网站的基础。</p>
</blockquote>
<p>不足的地方还很多，比如日期是读取文件修改日期，简介只是粗暴的截取第一段填充字数，这些随着使用过程再改了。</p>
<p>关于之后能写的目标，尽量做到避免文章标题复制给 ai 能写出相似更好的内容，这样太糟糕了。</p>

    </content>
  </entry>
  <entry>
    <title>《萤》读书笔记</title>
    <link href="https://tanzhijian.org/posts/firefly"></link>
    <id>1679403673.5903647</id>
    <updated>2023-03-21T21:01:13Z</updated>
    <published>2023-03-21T21:01:13Z</published>
    <author><name>tanzhijian</name></author>
    <summary>翻开这本书时想起了一个小插曲。几年前由于工作原因，需要经常和一个朋友交接，一来二去熟络起来后，偶尔会聊上一些生活。有一次朋友说起正在看一部叫《燃烧》的电影，我没有听说过。
</summary>
    <content type="html">
      <h1>《萤》读书笔记</h1>
<p>翻开这本书时想起了一个小插曲。几年前由于工作原因，需要经常和一个朋友交接，一来二去熟络起来后，偶尔会聊上一些生活。有一次朋友说起正在看一部叫《燃烧》的电影，我没有听说过。</p>
<p>“就是村上春树的小说《烧仓房》改编的。”</p>
<p>“我也没读过《烧仓房》。”</p>
<p>“这。。。你不是很喜欢他吗？”</p>
<p>“不过是个随波逐流的读者罢了。短篇小说陆陆续续读一些，但不记得有这一篇了。”</p>
<p>几天后我收到一个快递，是《萤》这本书。封页写上了一行寄语：“镜子里显现出的，只是表面的真相。”字体秀气。</p>
<p>博尔赫斯的诗。但我并未去想它的含义，也并未去读这本书，很快被我放进书柜了。当时周围不断发生着各种各样的事，应付这些已经精疲力竭，根本没有余力停下步子，等到我再次想起这个朋友时，已经随着工作的变迁渐行渐远了。我仍然能记起朋友说话时永远一副小心翼翼的模样，只是，朋友叫什么名字来着？</p>
<p>言归正传，说回这本书。</p>
<p>《烧仓房》依然是村上春树万年不变的主题，高度发达的资本主义社会与社会边缘人物，这次直白探讨了它们之间的关系。一共有三个人物，我，年轻女孩，她的富哥男朋友，其中我和年轻女孩——一个是无所事事的落魄作家，一个是打零工赚取必要生活开支——社会边缘人物，而富哥男朋友：“做什么不知道，反正就是有钱，谜一样的小伙子。”“简直成了菲茨杰拉德的《了不起的盖茨比》。”</p>
<p>谈到这篇小说的隐喻无非就两个，年轻女孩，以及仓房。富哥男朋友告诉我，他有一种叫做烧仓房的嗜好，就是偷偷地用汽油点燃别人家废弃的仓房，并用望远镜观看火焰。他说这样做是为了维持一种道德上的平衡感。小说中对于仓房的描述：</p>
<blockquote>
<p>海边孤零零的仓房，田地中间的仓房……反正各种各样的仓房。只消十五分钟就烧的一干二净，简直像压根儿不存在那玩意儿。谁都不伤心。只是——消失而已，忽地。</p>
<p>第三处仓房和第四处仓房酷似又老又丑的双胞胎，相距也不过两百米，哪个都那么陈旧那么污秽，甚至叫人觉得要烧索性一起烧掉罢了。</p>
<p>建筑物——我不知道能否称其为建筑物——几乎已经开始解体。的确如他所说，看上去果真像在静等谁来点上一把火。</p>
</blockquote>
<p>社会边缘人物。</p>
<p>故事的最后我碰到了富哥男朋友，他说他已经烧掉了附近最好最值得烧的，但却不是我所找的的任何一个仓房。我还想追问，被他打住了，随后问起年轻女孩的下落，消失了。</p>
<p>我看了很多解读，包括电影《燃烧》，到这里都在讨论，烧仓房只是象征，被真正“烧”掉的是年轻女孩，以及随之而来的阶层固化，上层阶级对于道德甚至法律的话语权，等等。</p>
<p>在我看来本书的结尾处理才是这篇小说仅仅想要表达的主题，一个更绝望的主题：只需要安排一个结局罢了。</p>
<p>至于哪座仓房被真正烧掉了，年轻女孩又是否真的消失了，谁在意呢？</p>

    </content>
  </entry>
  
</feed>